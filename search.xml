<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java反编译工具</title>
    <url>/p/87ac8aff/</url>
    <content><![CDATA[<h2 id="Procyon"><a href="#Procyon" class="headerlink" title="Procyon"></a><a href="https://bitbucket.org/mstrobel/procyon/wiki/Java%20Decompiler">Procyon</a></h2><p>作者：Mike Strobel<br>更新于2015年从Java 5把手语言增强功能和超越，最多的Java 8，其中包括：</p>
<ol>
<li>枚举声明</li>
<li>枚举和字符串</li>
<li>switch语句</li>
<li>局部类（匿名和命名）</li>
<li>注释</li>
<li>Java8和lambda表达式方法引用（即::运算符）。</li>
<li>Java 7中才能运行。</li>
</ol>
<h2 id="CFR"><a href="#CFR" class="headerlink" title="CFR"></a><a href="http://www.benf.org/other/cfr/">CFR</a></h2><p>作者：Lee Benfield<br>更新于2015年CFR能够编译现代Java功能-的Java 8 Lambda表达式（之前和之后的Java测试103的变化），Java7的字符串开关等，但完全用Java 6中。</p>
<h2 id="JD"><a href="#JD" class="headerlink" title="JD"></a><a href="http://jd.benow.ca/">JD</a></h2><p>作者：Emmanuel Dupuy<br>更新在2014年拥有自己的可视化界面和插件到Eclipse和IntelliJ。用C++编写，所以速度非常快。支持Java 5。</p>
<h2 id="Fernflower"><a href="#Fernflower" class="headerlink" title="Fernflower"></a><a href="https://github.com/fesh0r/fernflower">Fernflower</a></h2><p>作者：Egor Ushakov<br>更新在2015年非常有前景分析的Java反编译器，现在变成了14的IntelliJ（的一个组成部分看多）<br>支持Java多达6个版本（注解，泛型，枚举）</p>
<h2 id="Krakatau"><a href="#Krakatau" class="headerlink" title="Krakatau"></a><a href="https://github.com/Storyyeller/Krakatau">Krakatau</a></h2><p>作者：Robert Grosse<br>用Python编写的，包括一个强大的验证。它集中于翻译任意字节代码转换成有效的Java代码，而不是重构原始代码。</p>
<h2 id="Candle"><a href="#Candle" class="headerlink" title="Candle"></a><a href="https://github.com/bradsdavis/candle-decompiler">Candle</a></h2><p>作者：Brad Davis<br>JBoss Cake是一位正在进行中的早期，但有前途的工作的开发者。</p>
<h2 id="JAD"><a href="#JAD" class="headerlink" title="JAD"></a><a href="http://www.javadecompilers.com/jad">JAD</a></h2><p>作者：Pavel Kouznetsov<br>也许，这是最流行 ​​的Java反编译器，但主要只是这个时代的。用C++编写，所以速度非常快。过时的，不支持，不正确编译的Java 5及更高版本。</p>
<h2 id="Jadx"><a href="#Jadx" class="headerlink" title="Jadx"></a><a href="https://sourceforge.net/projects/jadx/files/">Jadx</a></h2><p>Android应用程序包（APK）是用于分发和安装应用软件到谷歌的Android操作系统软件包文件格式。<br>本网站采用完善的开源APK和DEX反编译器叫Jadx，看到更多的<br>Jadx反编译的.class和.jar文件，但还可以从Android的Dex文件和APK文件中直接生成Java源代码。</p>
<h2 id="ClassyShark"><a href="#ClassyShark" class="headerlink" title="ClassyShark"></a><a href="https://github.com/google/android-classyshark">ClassyShark</a></h2><p>作者：Boris Farber<br>ClassyShark是Android开发一个独立的工具。它可以可靠地浏览任何Android的可执行文件，并显示出重要的信息，如类接口和成员，DEX计数和依赖关系。 浏览器支持多种格式，包括库（.dex，.aar，.so），可执行文件（.apk文件，的.jar。类）和AndroidManifest（.xml）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.javadecompilers.com/">在线反编译器</a></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>我的 Android Studio 插件（不间断更新）</title>
    <url>/p/cc866726/</url>
    <content><![CDATA[<span id="more"></span>

<p><img src="http://7vik6r.com1.z0.glb.clouddn.com/image/jpg/blog/studio-hero.jpg" alt="Android Studio"></p>
<h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><ul>
<li>整理自己的习惯，也希望你有好的插件可以留言推荐给我，能提高效率的事情我非常需要！</li>
<li>不对下面扩展进行再详细介绍，具体点击到扩展主页可以看到对应的说明。</li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><ul>
<li><a href="https://github.com/Chgocn/android-studio-plugins">Chgocn-AndroidStudio-插件备份集</a></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>进入C:\Users\yourComputerUserName.AndroidStudio2.X\config\plugins</p>
<pre><code> git clone https://github.com/Chgocn/android-studio-plugins
</code></pre>
</li>
<li><p>重启Android Studio</p>
</li>
</ol>
<h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><h4 id="2016-08-16添加yaml支持"><a href="#2016-08-16添加yaml支持" class="headerlink" title="2016.08.16添加yaml支持"></a>2016.08.16添加yaml支持</h4><ul>
<li><strong>SnakeYAML</strong>：<a href="https://plugins.jetbrains.com/plugin/8142?pr=idea">https://plugins.jetbrains.com/plugin/8142?pr=idea</a></li>
<li><strong>YAML/Ansible support</strong>：<a href="https://plugins.jetbrains.com/plugin/7792?pr=idea">https://plugins.jetbrains.com/plugin/7792?pr=idea</a></li>
</ul>
<h4 id="2016-08-04更新"><a href="#2016-08-04更新" class="headerlink" title="2016.08.04更新"></a>2016.08.04更新</h4><ul>
<li><strong>PlantUML</strong>：<a href="https://plugins.jetbrains.com/plugin/7017?pr=phpStorm">https://plugins.jetbrains.com/plugin/7017?pr=phpStorm</a></li>
</ul>
<h4 id="2016-08-02更新"><a href="#2016-08-02更新" class="headerlink" title="2016.08.02更新"></a>2016.08.02更新</h4><ul>
<li><strong>WakaTime</strong>：<a href="https://github.com/wakatime/jetbrains-wakatime">https://github.com/wakatime/jetbrains-wakatime</a></li>
</ul>
<h4 id="2016-07-23更新"><a href="#2016-07-23更新" class="headerlink" title="2016.07.23更新"></a>2016.07.23更新</h4><ul>
<li><strong>jetbrains Android Studio插件官网</strong>：<a href="https://plugins.jetbrains.com/?androidstudio/">https://plugins.jetbrains.com/?androidstudio/</a></li>
<li><strong>Material Theme UI</strong>：<a href="https://plugins.jetbrains.com/plugin/8006?pr=androidstudio">https://plugins.jetbrains.com/plugin/8006?pr=androidstudio</a></li>
<li><strong>CheckStyle-IDEA</strong>：<a href="https://plugins.jetbrains.com/plugin/1065?pr=androidstudio">https://plugins.jetbrains.com/plugin/1065?pr=androidstudio</a><!-- //- **.ignore**：<https://addons.mozilla.org/zh-CN/firefox/addon/xmarks-sync> --></li>
<li><strong>Android ButterKnife Zelezny ²</strong>：<a href="https://plugins.jetbrains.com/plugin/7369?pr=androidstudio">https://plugins.jetbrains.com/plugin/7369?pr=androidstudio</a></li>
<li><strong>Android Code Generator</strong>：<a href="https://plugins.jetbrains.com/plugin/7595?pr=androidstudio/">https://plugins.jetbrains.com/plugin/7595?pr=androidstudio/</a></li>
<li><strong>Lifecycle Sorter</strong>：<a href="https://plugins.jetbrains.com/plugin/7742?pr=androidstudio">https://plugins.jetbrains.com/plugin/7742?pr=androidstudio</a></li>
<li><strong>findBugs-IDEA</strong>：<a href="https://plugins.jetbrains.com/plugin/3847?pr=androidstudio">https://plugins.jetbrains.com/plugin/3847?pr=androidstudio</a></li>
<li><strong>Android Styler</strong>：<a href="https://plugins.jetbrains.com/plugin/7972?pr=androidstudio">https://plugins.jetbrains.com/plugin/7972?pr=androidstudio</a></li>
<li><strong>SelectorChapek for Android</strong>：<a href="https://plugins.jetbrains.com/plugin/7298?pr=androidstudio">https://plugins.jetbrains.com/plugin/7298?pr=androidstudio</a></li>
<li><strong>Gradle Dependencies Helper</strong>：<a href="https://plugins.jetbrains.com/plugin/7299?pr=androidstudio">https://plugins.jetbrains.com/plugin/7299?pr=androidstudio</a></li>
<li><strong>folding-plugin</strong>：<a href="https://github.com/dmytrodanylyk/folding-plugin">https://github.com/dmytrodanylyk/folding-plugin</a></li>
<li><strong>.ignore</strong>：<a href="https://plugins.jetbrains.com/plugin/7495?pr=androidstudio">https://plugins.jetbrains.com/plugin/7495?pr=androidstudio</a></li>
<li><strong>Markdown Navigator</strong>：<a href="https://plugins.jetbrains.com/plugin/7896?pr=androidstudio">https://plugins.jetbrains.com/plugin/7896?pr=androidstudio</a></li>
<li><strong>ECTranslation</strong>：<a href="https://plugins.jetbrains.com/plugin/8469?pr=androidstudio/">https://plugins.jetbrains.com/plugin/8469?pr=androidstudio/</a></li>
<li><strong>Android Localizationer</strong>：<a href="https://plugins.jetbrains.com/plugin/7629?pr=androidstudio">https://plugins.jetbrains.com/plugin/7629?pr=androidstudio</a></li>
<li><strong>Android Methods Count</strong>：<a href="https://plugins.jetbrains.com/plugin/8076?pr=androidstudio">https://plugins.jetbrains.com/plugin/8076?pr=androidstudio</a></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://gold.xitu.io/entry/57909b46128fe1005693acf8"><strong>Android Studio插件整理</strong></a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android5.x新特性之 Toolbar和Theme的使用</title>
    <url>/p/5fd8b403/</url>
    <content><![CDATA[<p>Android5.x新特性之 Toolbar和Theme的使用:<a href="http://www.2cto.com/kf/201506/407276.html">http://www.2cto.com/kf/201506/407276.html</a></p>
<span id="more"></span>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li>colorPrimary: Toolbar导航栏的底色。</li>
<li>colorPrimaryDark：状态栏的底色，注意这里只支持Android5.0以上的手机。</li>
<li>textColorPrimary：整个当前Activity的字体的默认颜色。</li>
<li>android:windowBackground：当前Activity的窗体颜色。</li>
<li>colorAccent：CheckBox，RadioButton，SwitchCompat等控件的点击选中颜色</li>
<li>colorControlNormal：CheckBox，RadioButton，SwitchCompat等默认状态的颜色。</li>
<li>colorButtonNormal：默认状态下Button按钮的颜色。</li>
<li>editTextColor：默认EditView输入框字体的颜色。</li>
</ol>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>请结合：<a href="http://www.materialpalette.com/">http://www.materialpalette.com/</a>   下载XML文件进行配置。</p>
<pre><code>    &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
            &lt;!--导航栏底色--&gt;
            &lt;item name=colorPrimary&gt;@color/accent_material_dark&lt;/item&gt;
            &lt;!--状态栏底色--&gt;
            &lt;item name=colorPrimaryDark&gt;@color/accent_material_light&lt;/item&gt;
            &lt;!--导航栏上的标题颜色--&gt;
            &lt;item name=android:textColorPrimary&gt;@android:color/black&lt;/item&gt;
            &lt;!--Activity窗口的颜色--&gt;
            &lt;item name=android:windowBackground&gt;@color/material_blue_grey_800&lt;/item&gt;
            &lt;!--按钮选中或者点击获得焦点后的颜色--&gt;
            &lt;item name=colorAccent&gt;#00ff00&lt;/item&gt;
            &lt;!--和 colorAccent相反，正常状态下按钮的颜色--&gt;
            &lt;item name=colorControlNormal&gt;#ff0000&lt;/item&gt;
            &lt;!--Button按钮正常状态颜色--&gt;
            &lt;item name=colorButtonNormal&gt;@color/accent_material_light&lt;/item&gt;
            &lt;!--EditText 输入框中字体的颜色--&gt;
            &lt;item name=editTextColor&gt;@android:color/white&lt;/item&gt;
    &lt;/style&gt;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>apk脱壳+回编译+重新签名</title>
    <url>/p/f5ba4ed6/</url>
    <content><![CDATA[<h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>得到classes.dex文件</p>
<h3 id="通过baksmali将dex文件转换成smail文件"><a href="#通过baksmali将dex文件转换成smail文件" class="headerlink" title="通过baksmali将dex文件转换成smail文件"></a>通过baksmali将dex文件转换成smail文件</h3><p>运行命令后，smail文件在 out 目录下</p>
<pre><code>java -jar baksmail.jar d input.dex
</code></pre>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>xx.apk 为apk的名称</p>
<pre><code>java -jar apktool.jar d xx.apk
</code></pre>
<h3 id="替换文件"><a href="#替换文件" class="headerlink" title="替换文件"></a>替换文件</h3><p>将转成的smail文件的根目录改名为smail，然后替换反编译后里的smail</p>
<h3 id="回编译"><a href="#回编译" class="headerlink" title="回编译"></a>回编译</h3><p>xx 为文件夹名称</p>
<pre><code>java -jar apktool.jar b xx
</code></pre>
<h3 id="apksigner签名"><a href="#apksigner签名" class="headerlink" title="apksigner签名"></a>apksigner签名</h3><pre><code>java -jar apksigner.jar sign  --ks C:\workspace\android\Hookie\chgocn.jks  --ks-key-alias ch  --ks-pass pass:ca  --key-pass pass:ca  --out apk_dest.apk  base/dist/base.apk
</code></pre>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>adb install -r apk_dest.apk
</code></pre>
<h3 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h3><ul>
<li>java.lang.NoClassDefFoundError: Failed resolution of: Lkotlin/jvm/internal/Intrinsics</li>
</ul>
<p>原 apk 使用 kotlin 开发，360加壳，脱壳之后回编译时点击 app 闪退。</p>
<p>原因：脱壳拿到的dex文件中缺失 kotlin 依赖，需要自编译app，然后取出kotlin smail文件，并加进去</p>
<ul>
<li>找不到 com.stub.StubApp</li>
</ul>
<p>删除加固so文件以及修改application入口之后，还需要修改 smail 代码，将 StubApp的代码全部删除</p>
<p>- </p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>app 架构设计</title>
    <url>/p/7a886088/</url>
    <content><![CDATA[<p>这是一个比较通用的app架构设计，主要分【应用层】、【业务层】、【核心层】以及【基础层】</p>
<img src="https://os-buket.oss-cn-hangzhou.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220623105811-16559622649141.png" alt="微信图片_20220623105811" style="zoom:24%;" />

<p>这里我们简化下 app 架构，把核心层下沉到基础层中，与UI、Api同等重要。</p>
<p><img src="https://os-buket.oss-cn-hangzhou.aliyuncs.com/img/flutter_app%20(3).jpg" alt="flutter_app (3)"></p>
<h3 id="解语"><a href="#解语" class="headerlink" title="解语"></a>解语</h3><h4 id="基础层"><a href="#基础层" class="headerlink" title="基础层"></a>基础层</h4><p>这里我把 Core 和 UI 、Api 都放到了基础层。</p>
<p><strong>Core</strong>: 这里我把日志、存储、基类、工具类都归纳到基础层，博主认为可以<strong>沉淀下来的东西</strong>都可以放到基础层。</p>
<p><strong>UI</strong>: 一个公司的产品都应该是有规范的，设计更是如此，这样才能保证多端产品的产品特性。所以我们这里的UI层是根据设计规范开发实现的一整套UI组件，当然这里也包括一些通用性的布局等。</p>
<p><strong>Api</strong>: 接口。App应用基本都需要联网，那么接口就成了不可或缺的部分。这里会封装model、以及具体请求的实现，业务层只需要调用即可。</p>
<p>这里并不是要把Core、UI、Api统一封装起来，而是要单独抽取。</p>
<h4 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h4><p>这里的业务层就比较广泛。如果App功能体量小，这里的业务1、业务2、业务3可能是登录、设置、探索等；当然App功能如果对应服务比较多，建议根据后端服务去划分业务，比如文件中心、支撑中心、服务中心等。</p>
<p>业务层立于基础层之上，需要完成具体业务和UI设计。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>这里的应用层，是App的入口。从开发角度来说，我们把它定义成一个壳子。</p>
]]></content>
  </entry>
  <entry>
    <title>Cannot resolve symbol AppCompatActivity</title>
    <url>/p/17eebd65/</url>
    <content><![CDATA[<h2 id="正确步骤"><a href="#正确步骤" class="headerlink" title="正确步骤"></a>正确步骤</h2><ol>
<li><strong>尝试了删除. idea 目录下内容，再重新编译。无效</strong></li>
<li><strong>尝试清楚缓存：File -&gt; Invalidate Caches -&gt; Invalidate and Restart 。无效</strong></li>
<li><strong>手动升级 AGP 版本，参考</strong><a href="https://developer.android.google.cn/studio/releases/gradle-plugin">Android Gradle 插件版本对照表</a>，建议使用对应的 Gradle 版本和 AGP 版本</li>
</ol>
<h2 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h2><p><strong>环境</strong></p>
<ol>
<li><strong>Android Studio: Android Studio Electric Eel | 2022.1.1</strong></li>
<li><strong>project gradle: 3.2.0</strong></li>
<li><strong>project gradle wrapper: 4.8.1</strong></li>
</ol>
<p><strong>项目可以正常运行，但是 AS 里面报红，提示无法解析到 v7 包，找不到 android.support.v7.app.AppCompatActivity。</strong></p>
<p><strong>控制台错误信息如下：</strong></p>
<pre><code>Cannot resolve symbol &#39;v7&#39;
Cannot resolve symbol &#39;AppCompatActivity&#39;
...
</code></pre>
<h2 id="尝试方案"><a href="#尝试方案" class="headerlink" title="尝试方案"></a>尝试方案</h2><ol>
<li><strong>删除. idea 目录下内容，再重新编译。无效</strong></li>
<li><strong>清除缓存：File -&gt; Invalidate Caches -&gt; Invalidate and Restart 。无效</strong></li>
<li><strong>删除recent project，重新导入该项目。无效</strong></li>
<li><strong>升级android studio为最新版本。无效</strong></li>
</ol>
<p><strong>如果忘记原项目是否可以运行，参考：</strong></p>
<ol>
<li><strong>检查你的 build.gradle 文件中是否已经正确地添加了 com.android.support:appcompat-v7 依赖。</strong></li>
<li><strong>检查你的 Android Studio 版本是否过旧，如果是的话，升级到最新版本。</strong></li>
<li><strong>检查你的项目是否正确地配置了 Android Support Library。</strong></li>
<li><strong>执行 gradle 的 clean 操作并重新构建项目</strong></li>
</ol>
<h2 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h2><p><strong>无意中看到了 AS 的提示：</strong><br><strong>Project update recommended: Android Gradle Plugin can be upgraded.</strong></p>
<p><img src="https://img-blog.csdnimg.cn/f60b51fdde444e54afc2d69f8d7609c7.png"></p>
<p><strong>抱着试一试的心态，点击了 AS 的升级按钮 upgraded ，根据提示操作，问题解决。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Hexo插件</title>
    <url>/p/1562b2a5/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>插件</th>
<th>功能</th>
<th>文档链接</th>
</tr>
</thead>
<tbody><tr>
<td>hexo-generator-index-pin-top</td>
<td>文章置顶</td>
<td><a href="https://github.com/netcan/hexo-generator-index-pin-top">https://github.com/netcan/hexo-generator-index-pin-top</a></td>
</tr>
<tr>
<td>hexo-wordcount</td>
<td>文章字数统计和阅读时长统计</td>
<td><a href="https://github.com/willin/hexo-wordcount">https://github.com/willin/hexo-wordcount</a></td>
</tr>
<tr>
<td>hexo-abbrlink</td>
<td>生成URL短链接</td>
<td><a href="https://github.com/rozbo/hexo-abbrlink">https://github.com/rozbo/hexo-abbrlink</a></td>
</tr>
<tr>
<td>hexo-lazyload-image</td>
<td>图片懒加载</td>
<td><a href="https://github.com/Troy-Yang/hexo-lazyload-image">https://github.com/Troy-Yang/hexo-lazyload-image</a></td>
</tr>
<tr>
<td>hexo-generator-baidu-sitemap</td>
<td>生成baidusitemap.xml</td>
<td><a href="https://github.com/coneycode/hexo-generator-baidu-sitemap">https://github.com/coneycode/hexo-generator-baidu-sitemap</a></td>
</tr>
<tr>
<td>hexo-generator-sitemap</td>
<td>生成sitemap.xml</td>
<td><a href="https://github.com/hexojs/hexo-generator-sitemap">https://github.com/hexojs/hexo-generator-sitemap</a></td>
</tr>
<tr>
<td>hexo-generator-feed</td>
<td>生成RSS文件</td>
<td><a href="https://github.com/hexojs/hexo-generator-feed">https://github.com/hexojs/hexo-generator-feed</a></td>
</tr>
<tr>
<td>hexo-external-link</td>
<td>外链跳转</td>
<td><a href="https://github.com/hvnobug/hexo-external-link">https://github.com/hvnobug/hexo-external-link</a></td>
</tr>
<tr>
<td>hexo-autonofollow</td>
<td>自动对外部链接增加nofollow属性</td>
<td><a href="https://github.com/liuzc/hexo-autonofollow">https://github.com/liuzc/hexo-autonofollow</a></td>
</tr>
<tr>
<td>hexo-filter-nofollow</td>
<td>为外链添加rel=”noopener external nofollow noreferrer”</td>
<td><a href="https://github.com/hexojs/hexo-filter-nofollow">https://github.com/hexojs/hexo-filter-nofollow</a></td>
</tr>
<tr>
<td>hexo-prism-plugin</td>
<td>代码高亮</td>
<td><a href="https://github.com/ele828/hexo-prism-plugin">https://github.com/ele828/hexo-prism-plugin</a></td>
</tr>
<tr>
<td>hexo-neat</td>
<td>博客压缩</td>
<td><a href="https://github.com/rozbo/hexo-neat">https://github.com/rozbo/hexo-neat</a></td>
</tr>
<tr>
<td>hexo-allminifier</td>
<td>博客压缩</td>
<td><a href="https://developer.aliyun.com/mirror/npm/package/hexo-all-minifier">https://developer.aliyun.com/mirror/npm/package/hexo-all-minifier</a></td>
</tr>
<tr>
<td>hexo-tag-aplayer</td>
<td>aplayer音乐播放器</td>
<td><a href="https://github.com/MoePlayer/hexo-tag-aplayer">https://github.com/MoePlayer/hexo-tag-aplayer</a></td>
</tr>
<tr>
<td>hexo-tag-dplayer</td>
<td>dplayer视频播放器</td>
<td><a href="https://github.com/MoePlayer/hexo-tag-dplayer">https://github.com/MoePlayer/hexo-tag-dplayer</a></td>
</tr>
<tr>
<td>hexo-douban</td>
<td>添加豆瓣读书，电影，游戏页面</td>
<td><a href="https://github.com/mythsman/hexo-douban">https://github.com/mythsman/hexo-douban</a></td>
</tr>
<tr>
<td>hexo-generator-searchdb</td>
<td>本地搜索,生成search.xml</td>
<td><a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a></td>
</tr>
<tr>
<td>hexo-algoliasearch</td>
<td>搜索系统</td>
<td><a href="https://github.com/LouisBarranqueiro/hexo-algoliasearch">https://github.com/LouisBarranqueiro/hexo-algoliasearch</a></td>
</tr>
<tr>
<td>hexo-algolia</td>
<td>搜索系统</td>
<td><a href="https://github.com/oncletom/hexo-algolia">https://github.com/oncletom/hexo-algolia</a></td>
</tr>
<tr>
<td>hexo-generator-search</td>
<td>本地搜索系统</td>
<td><a href="https://github.com/wzpan/hexo-generator-search">https://github.com/wzpan/hexo-generator-search</a></td>
</tr>
<tr>
<td>hexo-baidu-url-submit</td>
<td>百度站长主动推送</td>
<td><a href="https://github.com/huiwang/hexo-baidu-url-submit">https://github.com/huiwang/hexo-baidu-url-submit</a></td>
</tr>
<tr>
<td>hexo-offline</td>
<td>开启PWA</td>
<td><a href="https://github.com/JLHwung/hexo-offline">https://github.com/JLHwung/hexo-offline</a></td>
</tr>
<tr>
<td>hexo-pwa</td>
<td>开启PWA</td>
<td><a href="https://github.com/lavas-project/hexo-pwa">https://github.com/lavas-project/hexo-pwa</a></td>
</tr>
<tr>
<td>hexo-helper-live2d</td>
<td>看板娘</td>
<td><a href="https://github.com/EYHN/hexo-helper-live2d">https://github.com/EYHN/hexo-helper-live2d</a></td>
</tr>
<tr>
<td>hexo-addlink</td>
<td>文末添加当前文章链接和版权声明</td>
<td><a href="https://github.com/acwong00/hexo-addlink">https://github.com/acwong00/hexo-addlink</a></td>
</tr>
<tr>
<td>hexo-blog-encrypt</td>
<td>博客文章加密</td>
<td><a href="https://github.com/MikeCoder/hexo-blog-encrypt">https://github.com/MikeCoder/hexo-blog-encrypt</a></td>
</tr>
<tr>
<td>hexo-simple-mindmap</td>
<td>博客添加脑图</td>
<td><a href="https://github.com/HunterXuan/hexo-simple-mindmap">https://github.com/HunterXuan/hexo-simple-mindmap</a></td>
</tr>
<tr>
<td>hexo-pdf</td>
<td>博客展示pdf</td>
<td><a href="https://github.com/superalsrk/hexo-pdf">https://github.com/superalsrk/hexo-pdf</a></td>
</tr>
<tr>
<td>hexo-tag-echarts</td>
<td>博客添加图表</td>
<td><a href="https://github.com/zhoulvjun/hexo-tag-echarts">https://github.com/zhoulvjun/hexo-tag-echarts</a></td>
</tr>
<tr>
<td>hexo-steam-games</td>
<td>添加Steam游戏界面</td>
<td><a href="https://github.com/HCLonely/hexo-steam-games">https://github.com/HCLonely/hexo-steam-games</a></td>
</tr>
<tr>
<td>hexo-bilibili-bangumi</td>
<td>添加bilibili番剧页面</td>
<td><a href="https://github.com/HCLonely/hexo-bilibili-bangumi">https://github.com/HCLonely/hexo-bilibili-bangumi</a></td>
</tr>
<tr>
<td>hexo-generator-random</td>
<td>生成随机文章页面</td>
<td><a href="https://github.com/Drew233/hexo-generator-random">https://github.com/Drew233/hexo-generator-random</a></td>
</tr>
<tr>
<td>hexo-web-push-notification</td>
<td>web推送插件</td>
<td><a href="https://github.com/glazec/hexo-web-push-notification">https://github.com/glazec/hexo-web-push-notification</a></td>
</tr>
</tbody></table>
<h2 id="Butterfly-专属插件"><a href="#Butterfly-专属插件" class="headerlink" title="Butterfly 专属插件"></a>Butterfly 专属插件</h2><table>
<thead>
<tr>
<th>插件</th>
<th>功能</th>
<th>文档链接或教程链接</th>
</tr>
</thead>
<tbody><tr>
<td>hexo-butterfly-article-double-row</td>
<td>首页文章显示两行</td>
<td><a href="https://zfe.space/post/hexo-butterfly-article-double-row.html">https://zfe.space/post/hexo-butterfly-article-double-row.html</a></td>
</tr>
<tr>
<td>hexo-butterfly-charts</td>
<td>博客文章、标签等统计图表</td>
<td><a href="https://guole.fun/posts/18158/">https://guole.fun/posts/18158/</a></td>
</tr>
<tr>
<td>hexo-butterfly-swiper</td>
<td>首页滚动baner图</td>
<td><a href="https://akilar.top/posts/8e1264d1/">https://akilar.top/posts/8e1264d1/</a></td>
</tr>
<tr>
<td>hexo-butterfly-hpptalk</td>
<td>说说</td>
<td><a href="https://github.com/jerryc127/butterfly-plugins">https://github.com/jerryc127/butterfly-plugins</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>Butterfly主题使用</title>
    <url>/p/f90668a2/</url>
    <content><![CDATA[<h2 id="标签使用"><a href="#标签使用" class="headerlink" title="标签使用"></a>标签使用</h2><pre><code class="bash"># 设置代理
set http_proxy=http://127.0.0.1:7890
set https_proxy=http://127.0.0.1:7890

# 移除代理
set http_proxy=
set https_proxy=

# 验证
curl -vv http://www.google.com
</code></pre>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB 开发文档</title>
    <url>/p/545d822b/</url>
    <content><![CDATA[<p>ADB，即 <a href="https://developer.android.com/studio/command-line/adb.html">Ancadroid Debug Bridge</a>，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。</p>
<p><strong>注：</strong> 文中有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。</p>
<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a><ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95">命令语法</a></li>
<li><a href="#%E4%B8%BA%E5%91%BD%E4%BB%A4%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87%E8%AE%BE%E5%A4%87">为命令指定目标设备</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2">启动/停止</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B-adb-%E7%89%88%E6%9C%AC">查看 adb 版本</a></li>
<li><a href="#%E4%BB%A5-root-%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C-adbd">以 root 权限运行 adbd</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A-adb-server-%E7%9A%84%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">指定 adb server 的网络端口</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">设备连接管理</a><ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%B7%B2%E8%BF%9E%E6%8E%A5%E8%AE%BE%E5%A4%87%E6%A8%A1%E6%8B%9F%E5%99%A8">查询已连接设备/模拟器</a></li>
<li><a href="#usb-%E8%BF%9E%E6%8E%A5">USB 连接</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5android11-%E5%8F%8A%E4%BB%A5%E4%B8%8A">无线连接（Android11 及以上）</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81%E5%80%9F%E5%8A%A9-usb-%E7%BA%BF">无线连接（需要借助 USB 线）</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%97%A0%E9%9C%80%E5%80%9F%E5%8A%A9-usb-%E7%BA%BF">无线连接（无需借助 USB 线）</a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86">应用管理</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%88%97%E8%A1%A8">查看应用列表</a><ul>
<li><a href="#%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8">所有应用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8">系统应用</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8">第三方应用</a></li>
<li><a href="#%E5%8C%85%E5%90%8D%E5%8C%85%E5%90%AB%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%94%E7%94%A8">包名包含某字符串的应用</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85-apk">安装 APK</a></li>
<li><a href="#%E5%8D%B8%E8%BD%BD%E5%BA%94%E7%94%A8">卸载应用</a></li>
<li><a href="#%E6%B8%85%E9%99%A4%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BC%93%E5%AD%98">清除应用数据与缓存</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%89%8D%E5%8F%B0-activity">查看前台 Activity</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-services">查看正在运行的 Services</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF">查看应用详细信息</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84">查看应用安装路径</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8E%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BA%92">与应用交互</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8-%E8%B0%83%E8%B5%B7-activity">启动应用/ 调起 Activity</a></li>
<li><a href="#%E8%B0%83%E8%B5%B7-service">调起 Service</a></li>
<li><a href="#%E5%81%9C%E6%AD%A2-service">停止 Service</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD">发送广播</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%BA%94%E7%94%A8">强制停止应用</a></li>
<li><a href="#%E6%94%B6%E7%B4%A7%E5%86%85%E5%AD%98">收紧内存</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a><ul>
<li><a href="#%E5%A4%8D%E5%88%B6%E8%AE%BE%E5%A4%87%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0%E7%94%B5%E8%84%91">复制设备里的文件到电脑</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%94%B5%E8%84%91%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0%E8%AE%BE%E5%A4%87">复制电脑里的文件到设备</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5">模拟按键/输入</a><ul>
<li><a href="#%E7%94%B5%E6%BA%90%E9%94%AE">电源键</a></li>
<li><a href="#%E8%8F%9C%E5%8D%95%E9%94%AE">菜单键</a></li>
<li><a href="#home-%E9%94%AE">HOME 键</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E9%94%AE">返回键</a></li>
<li><a href="#%E9%9F%B3%E9%87%8F%E6%8E%A7%E5%88%B6">音量控制</a></li>
<li><a href="#%E5%AA%92%E4%BD%93%E6%8E%A7%E5%88%B6">媒体控制</a></li>
<li><a href="#%E7%82%B9%E4%BA%AE%E7%86%84%E7%81%AD%E5%B1%8F%E5%B9%95">点亮/熄灭屏幕</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81">滑动解锁</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC">输入文本</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97">查看日志</a><ul>
<li><a href="#android-%E6%97%A5%E5%BF%97">Android 日志</a><ul>
<li><a href="#%E6%8C%89%E7%BA%A7%E5%88%AB%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按级别过滤日志</a></li>
<li><a href="#%E6%8C%89-tag-%E5%92%8C%E7%BA%A7%E5%88%AB%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按 tag 和级别过滤日志</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F">日志格式</a></li>
<li><a href="#%E6%B8%85%E7%A9%BA%E6%97%A5%E5%BF%97">清空日志</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E6%A0%B8%E6%97%A5%E5%BF%97">内核日志</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF">查看设备信息</a><ul>
<li><a href="#%E5%9E%8B%E5%8F%B7">型号</a></li>
<li><a href="#%E7%94%B5%E6%B1%A0%E7%8A%B6%E5%86%B5">电池状况</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87">屏幕分辨率</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6">屏幕密度</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E6%95%B0">显示屏参数</a></li>
<li><a href="#android_id">android_id</a></li>
<li><a href="#imei">IMEI</a></li>
<li><a href="#android-%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC">Android 系统版本</a></li>
<li><a href="#ip-%E5%9C%B0%E5%9D%80">IP 地址</a></li>
<li><a href="#mac-%E5%9C%B0%E5%9D%80">Mac 地址</a></li>
<li><a href="#cpu-%E4%BF%A1%E6%81%AF">CPU 信息</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF">内存信息</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7">更多硬件与系统属性</a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%AE%BE%E7%BD%AE">修改设置</a><ul>
<li><a href="#%E5%88%86%E8%BE%A8%E7%8E%87">分辨率</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6-1">屏幕密度</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%8C%BA%E5%9F%9F">显示区域</a></li>
<li><a href="#%E5%85%B3%E9%97%AD-usb-%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F">关闭 USB 调试模式</a></li>
<li><a href="#%E5%85%81%E8%AE%B8%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE%E9%9D%9E-sdk-api">允许/禁止访问非 SDK API</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E6%A0%8F%E5%92%8C%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F">状态栏和导航栏的显示隐藏</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD">实用功能</a><ul>
<li><a href="#%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">屏幕截图</a></li>
<li><a href="#%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95">录制屏幕</a></li>
<li><a href="#%E9%87%8D%E6%96%B0%E6%8C%82%E8%BD%BD-system-%E5%88%86%E5%8C%BA%E4%B8%BA%E5%8F%AF%E5%86%99">重新挂载 system 分区为可写</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84-wifi-%E5%AF%86%E7%A0%81">查看连接过的 WiFi 密码</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4">设置系统日期和时间</a></li>
<li><a href="#%E9%87%8D%E5%90%AF%E6%89%8B%E6%9C%BA">重启手机</a></li>
<li><a href="#%E6%A3%80%E6%B5%8B%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E5%B7%B2-root">检测设备是否已 root</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-monkey-%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95">使用 Monkey 进行压力测试</a></li>
<li><a href="#%E5%BC%80%E5%90%AF%E5%85%B3%E9%97%AD-wifi">开启/关闭 WiFi</a></li>
</ul>
</li>
<li><a href="#%E5%88%B7%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">刷机相关命令</a><ul>
<li><a href="#%E9%87%8D%E5%90%AF%E5%88%B0-recovery-%E6%A8%A1%E5%BC%8F">重启到 Recovery 模式</a></li>
<li><a href="#%E4%BB%8E-recovery-%E9%87%8D%E5%90%AF%E5%88%B0-android">从 Recovery 重启到 Android</a></li>
<li><a href="#%E9%87%8D%E5%90%AF%E5%88%B0-fastboot-%E6%A8%A1%E5%BC%8F">重启到 Fastboot 模式</a></li>
<li><a href="#%E9%80%9A%E8%BF%87-sideload-%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F">通过 sideload 更新系统</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">安全相关命令</a><ul>
<li><a href="#%E5%90%AF%E7%94%A8%E7%A6%81%E7%94%A8-selinux">启用/禁用 SELinux</a></li>
<li><a href="#%E5%90%AF%E7%94%A8%E7%A6%81%E7%94%A8-dm_verity">启用/禁用 dm_verity</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B4%E5%A4%9A-adb-shell-%E5%91%BD%E4%BB%A4">更多 adb shell 命令</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">查看进程</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5">查看实时资源占用情况</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-uid">查看进程 UID</a></li>
<li><a href="#%E5%85%B6%E5%AE%83">其它</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8-adb-server-%E5%A4%B1%E8%B4%A5">启动 adb server 失败</a></li>
<li><a href="#comandroidddmlibadbcommandrejectedexception">com.android.ddmlib.AdbCommandRejectedException</a></li>
</ul>
</li>
<li><a href="#adb-%E7%9A%84%E9%9D%9E%E5%AE%98%E6%96%B9%E5%AE%9E%E7%8E%B0">adb 的非官方实现</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">相关命令</a></li>
<li><a href="#%E8%87%B4%E8%B0%A2">致谢</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
<!-- vim-markdown-toc -->

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3><p>adb 命令的基本语法如下：</p>
<pre><code class="sh">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt;
</code></pre>
<p>如果只有一个设备/模拟器连接时，可以省略掉 <code>[-d|-e|-s &lt;serialNumber&gt;]</code> 这一部分，直接使用 <code>adb &lt;command&gt;</code>。</p>
<h3 id="为命令指定目标设备"><a href="#为命令指定目标设备" class="headerlink" title="为命令指定目标设备"></a>为命令指定目标设备</h3><p>如果有多个设备/模拟器连接，则需要为命令指定目标设备。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s </code></td>
<td>指定相应 serialNumber 号的设备/模拟器为命令目标</td>
</tr>
</tbody></table>
<p>在多个设备/模拟器连接的情况下较常用的是 <code>-s &lt;serialNumber&gt;</code> 参数，serialNumber 可以通过 <code>adb devices</code> 命令获取。如：</p>
<pre><code class="sh">$ adb devices

List of devices attached
cf264b8f    device
emulator-5554    device
10.129.164.6:5555    device
</code></pre>
<p>输出里的 <code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 即为 serialNumber。</p>
<p>比如这时想指定 <code>cf264b8f</code> 这个设备来运行 adb 命令获取屏幕分辨率：</p>
<pre><code class="sh">adb -s cf264b8f shell wm size
</code></pre>
<p>又如想给 <code>10.129.164.6:5555</code> 这个设备安装应用（<em>这种形式的 serialNumber 格式为 <code>&lt;IP&gt;:&lt;Port&gt;</code>，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器</em>）：</p>
<pre><code class="sh">adb -s 10.129.164.6:5555 install test.apk
</code></pre>
<p><strong>遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。</strong></p>
<h3 id="启动-停止"><a href="#启动-停止" class="headerlink" title="启动/停止"></a>启动/停止</h3><p>启动 adb server 命令：</p>
<pre><code class="sh">adb start-server
</code></pre>
<p>（一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。）</p>
<p>停止 adb server 命令：</p>
<pre><code class="sh">adb kill-server
</code></pre>
<h3 id="查看-adb-版本"><a href="#查看-adb-版本" class="headerlink" title="查看 adb 版本"></a>查看 adb 版本</h3><p>命令：</p>
<pre><code class="sh">adb version
</code></pre>
<p>示例输出：</p>
<pre><code class="sh">Android Debug Bridge version 1.0.36
Revision 8f855a3d9b35-android
</code></pre>
<h3 id="以-root-权限运行-adbd"><a href="#以-root-权限运行-adbd" class="headerlink" title="以 root 权限运行 adbd"></a>以 root 权限运行 adbd</h3><p>adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p>
<p>所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 <code>adb xxx</code> 执行。这时可以 <code>adb shell</code> 然后 <code>su</code> 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p>
<p>命令：</p>
<pre><code class="sh">adb root
</code></pre>
<p>正常输出：</p>
<pre><code class="sh">restarting adbd as root
</code></pre>
<p>现在再运行 <code>adb shell</code>，看看命令行提示符是不是变成 <code>#</code> 了？</p>
<p>有些手机 root 后也无法通过 <code>adb root</code> 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 <code>adbd cannot run as root in production builds</code>，此时可以先安装 adbd Insecure，然后 <code>adb root</code> 试试。</p>
<p>相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 <code>adb unroot</code> 命令。</p>
<h3 id="指定-adb-server-的网络端口"><a href="#指定-adb-server-的网络端口" class="headerlink" title="指定 adb server 的网络端口"></a>指定 adb server 的网络端口</h3><p>命令：</p>
<pre><code class="sh">adb -P &lt;port&gt; start-server
</code></pre>
<p>默认端口为 5037。</p>
<h2 id="设备连接管理"><a href="#设备连接管理" class="headerlink" title="设备连接管理"></a>设备连接管理</h2><h3 id="查询已连接设备-模拟器"><a href="#查询已连接设备-模拟器" class="headerlink" title="查询已连接设备/模拟器"></a>查询已连接设备/模拟器</h3><p>命令：</p>
<pre><code class="sh">adb devices
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">List of devices attached
cf264b8f    device
emulator-5554    device
10.129.164.6:5555    device
</code></pre>
<p>输出格式为 <code>[serialNumber] [state]</code>，serialNumber 即我们常说的 SN，state 有如下几种：</p>
<ul>
<li><code>offline</code> —— 表示设备未连接成功或无响应。</li>
<li><code>device</code> —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。</li>
<li><code>no device</code> —— 没有设备/模拟器连接。</li>
</ul>
<p>以上输出显示当前已经连接了三台设备/模拟器，<code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 分别是它们的 SN。从 <code>emulator-5554</code> 这个名字可以看出它是一个 Android 模拟器，而 <code>10.129.164.6:5555</code> 这种形为 <code>&lt;IP&gt;:&lt;Port&gt;</code> 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。</p>
<p>常见异常输出：</p>
<ol>
<li>没有设备/模拟器连接成功。<pre><code class="sh">List of devices attached
</code></pre>
</li>
<li>设备/模拟器未连接到 adb 或无响应。<pre><code class="sh">List of devices attached
cf264b8f    offline
</code></pre>
</li>
</ol>
<h3 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h3><p>通过 USB 连接来正常使用 adb 需要保证几点：</p>
<ol>
<li>硬件状态正常。包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</li>
<li>Android 设备的开发者选项和 USB 调试模式已开启。可以到「设置」-「开发者选项」-「Android 调试」查看。如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</li>
<li>设备驱动状态正常。这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</li>
<li>通过 USB 线连接好电脑和设备后确认状态。<pre><code class="sh">adb devices
</code></pre>
如果能看到<pre><code class="sh">xxxxxx device
</code></pre>
说明连接成功。</li>
</ol>
<h3 id="无线连接（Android11-及以上）"><a href="#无线连接（Android11-及以上）" class="headerlink" title="无线连接（Android11 及以上）"></a>无线连接（Android11 及以上）</h3><p>Android 11 及更高版本支持使用 Android 调试桥 (adb) 从工作站以无线方式部署和调试应用。例如，您可以将可调试应用部署到多台远程设备，而无需通过 USB 实际连接设备。这样就可以避免常见的 USB 连接问题，例如驱动程序安装方面的问题。</p>
<p><a href="https://developer.android.com/studio/command-line/adb?hl=zh_cn#connect-to-a-device-over-wi-fi-android-11+">官方文档</a></p>
<p>操作步骤：</p>
<ol>
<li>更新到最新版本的 <a href="https://developer.android.com/studio/releases/platform-tools?hl=zh_cn">SDK 平台工具</a>(至少30.0.0)。</li>
<li>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</li>
<li>在开发者选项中启用<strong>无线调试</strong>。</li>
<li>在询问要允许在此网络上进行无线调试吗？的对话框中，点击允许。</li>
<li>选择使用配对码配对设备，使用弹窗中的 IP 地址和端口号。</li>
</ol>
<pre><code class="sh">adb pair ipaddr:port
</code></pre>
<ol start="6">
<li>提示<code>Enter pairing code: </code>时输入弹窗中的配对码，成功后会显示<code>Successfully paired to ...</code>。</li>
<li>使用无线调试下的 <strong>IP 地址和端口</strong>。</li>
</ol>
<pre><code class="sh">adb connect ipaddr:port
</code></pre>
<ol start="8">
<li>确认连接状态。<pre><code class="sh">adb devices
</code></pre>
如果能看到<pre><code class="sh">ipaddr:port device
</code></pre>
</li>
</ol>
<p>说明连接成功。</p>
<h3 id="无线连接（需要借助-USB-线）"><a href="#无线连接（需要借助-USB-线）" class="headerlink" title="无线连接（需要借助 USB 线）"></a>无线连接（需要借助 USB 线）</h3><p>除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！</p>
<p>操作步骤：</p>
<ol>
<li>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</li>
<li>将设备与电脑通过 USB 线连接。应确保连接成功（可运行 <code>adb devices</code> 看是否能列出该设备）。</li>
<li>让设备在 5555 端口监听 TCP/IP 连接：<pre><code class="sh">adb tcpip 5555
</code></pre>
</li>
<li>断开 USB 连接。</li>
<li>找到设备的 IP 地址。一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 [查看设备信息 - IP 地址][1]#ip-地址 一节里的方法用 adb 命令来查看。</li>
<li>通过 IP 地址连接设备。<pre><code class="sh">adb connect &lt;device-ip-address&gt;
</code></pre>
这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</li>
<li>确认连接状态。<pre><code class="sh">adb devices
</code></pre>
如果能看到<pre><code class="sh">&lt;device-ip-address&gt;:5555 device
</code></pre>
说明连接成功。</li>
</ol>
<p>如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 <code>adb connect &lt;device-ip-address&gt;</code> 那一步；</p>
<p>如果还是不行的话，通过 <code>adb kill-server</code> 重新启动 adb 然后从头再来一次试试。</p>
<p><strong>断开无线连接</strong></p>
<p>命令：</p>
<pre><code class="sh">adb disconnect &lt;device-ip-address&gt;
</code></pre>
<h3 id="无线连接（无需借助-USB-线）"><a href="#无线连接（无需借助-USB-线）" class="headerlink" title="无线连接（无需借助 USB 线）"></a>无线连接（无需借助 USB 线）</h3><p><strong>注：需要 root 权限。</strong></p>
<p>上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。</p>
<p>既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。</p>
<ol>
<li>在 Android 设备上安装一个终端模拟器。已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：<a href="https://jackpal.github.io/Android-Terminal-Emulator/">Terminal Emulator for Android Downloads</a></li>
<li>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</li>
<li>打开 Android 设备上的终端模拟器，在里面依次运行命令：<pre><code class="sh">su
setprop service.adb.tcp.port 5555
</code></pre>
</li>
<li>找到 Android 设备的 IP 地址。一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 [查看设备信息 - IP 地址][1]#ip-地址 一节里的方法用 adb 命令来查看。</li>
<li>在电脑上通过 adb 和 IP 地址连接 Android 设备。<pre><code class="sh">adb connect &lt;device-ip-address&gt;
</code></pre>
这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。如果能看到 <code>connected to &lt;device-ip-address&gt;:5555</code> 这样的输出则表示连接成功。</li>
</ol>
<p><em>节注一：</em></p>
<p>有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行：</p>
<pre><code class="sh">restart adbd
</code></pre>
<p>如果 restart 无效，尝试以下命令：</p>
<pre><code class="sh">stop adbd
start adbd
</code></pre>
<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><h3 id="查看应用列表"><a href="#查看应用列表" class="headerlink" title="查看应用列表"></a>查看应用列表</h3><p>查看应用列表的基本命令格式是</p>
<pre><code class="sh">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]
</code></pre>
<p>即在 <code>adb shell pm list packages</code> 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td>``</td>
<td>包名包含 `` 字符串</td>
</tr>
</tbody></table>
<h4 id="所有应用"><a href="#所有应用" class="headerlink" title="所有应用"></a>所有应用</h4><p>命令：</p>
<pre><code class="sh">adb shell pm list packages
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">package:com.android.smoketest
package:com.example.android.livecubes
package:com.android.providers.telephony
package:com.google.android.googlequicksearchbox
package:com.android.providers.calendar
package:com.android.providers.media
package:com.android.protips
package:com.android.documentsui
package:com.android.gallery
package:com.android.externalstorage
...
// other packages here
...
</code></pre>
<h4 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h4><p>命令：</p>
<pre><code class="sh">adb shell pm list packages -s
</code></pre>
<h4 id="第三方应用"><a href="#第三方应用" class="headerlink" title="第三方应用"></a>第三方应用</h4><p>命令：</p>
<pre><code class="sh">adb shell pm list packages -3
</code></pre>
<h4 id="包名包含某字符串的应用"><a href="#包名包含某字符串的应用" class="headerlink" title="包名包含某字符串的应用"></a>包名包含某字符串的应用</h4><p>比如要查看包名包含字符串 <code>mazhuang</code> 的应用列表，命令：</p>
<pre><code class="sh">adb shell pm list packages mazhuang
</code></pre>
<p>当然也可以使用 grep 来过滤：</p>
<pre><code class="sh">adb shell pm list packages | grep mazhuang
</code></pre>
<h3 id="安装-APK"><a href="#安装-APK" class="headerlink" title="安装 APK"></a>安装 APK</h3><p>命令格式：</p>
<pre><code class="sh">adb install [-lrtsdg] &lt;path_to_apk&gt;
</code></pre>
<p>参数：</p>
<p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>将应用安装到保护目录 /mnt/asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
<tr>
<td>–abi abi-identifier</td>
<td>为特定 ABI 强制安装 apk，abi-identifier 可以是 armeabi-v7a、arm64-v8a、v86、x86_64 等</td>
</tr>
</tbody></table>
<p>运行命令后如果见到类似如下输出（状态为 <code>Success</code>）代表安装成功：</p>
<pre><code class="sh">[100%] /data/local/tmp/1.apk
    pkg: /data/local/tmp/1.apk
Success
</code></pre>
<p>上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。</p>
<p>使用旧版本 adb 的输出则是这样的：</p>
<pre><code class="sh">12040 KB/s (22205609 bytes in 1.801s)
        pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apk
Success
</code></pre>
<p>而如果状态为 <code>Failure</code> 则表示安装失败，比如：</p>
<pre><code class="sh">[100%] /data/local/tmp/map-20160831.apk
        pkg: /data/local/tmp/map-20160831.apk
Failure [INSTALL_FAILED_ALREADY_EXISTS]
</code></pre>
<p>常见安装失败输出代码、含义及可能的解决办法如下：</p>
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall </code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td>
<td>先 <code>adb uninstall </code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数;2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td>在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>APK 文件是使用 Android Studio 直接 RUN 编译出来的文件</td>
<td>通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK</td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on device</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied … sdcard …</td>
<td>sdcard 不可用</td>
<td></td>
</tr>
<tr>
<td>signatures do not match the previously installed version; ignoring!</td>
<td>已安装该应用且签名不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
</tbody></table>
<p>参考：<a href="https://github.com/android/platform_frameworks_base/blob/master/core%2Fjava%2Fandroid%2Fcontent%2Fpm%2FPackageManager.java">PackageManager.java</a></p>
<p><em><code>adb install</code> 内部原理简介</em></p>
<p><code>adb install</code> 实际是分三步完成：</p>
<ol>
<li>push apk 文件到 /data/local/tmp。</li>
<li>调用 pm install 安装。</li>
<li>删除 /data/local/tmp 下的对应 apk 文件。</li>
</ol>
<p>所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</p>
<h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><p>命令：</p>
<pre><code class="sh">adb uninstall [-k] &lt;packagename&gt;
</code></pre>
<p><code>&lt;packagename&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<p>命令示例：</p>
<pre><code class="sh">adb uninstall com.qihoo360.mobilesafe
</code></pre>
<p>表示卸载 360 手机卫士。</p>
<h3 id="清除应用数据与缓存"><a href="#清除应用数据与缓存" class="headerlink" title="清除应用数据与缓存"></a>清除应用数据与缓存</h3><p>命令：</p>
<pre><code class="sh">adb shell pm clear &lt;packagename&gt;
</code></pre>
<p><code>&lt;packagename&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<p>命令示例：</p>
<pre><code class="sh">adb shell pm clear com.qihoo360.mobilesafe
</code></pre>
<p>表示清除 360 手机卫士的数据和缓存。</p>
<h3 id="查看前台-Activity"><a href="#查看前台-Activity" class="headerlink" title="查看前台 Activity"></a>查看前台 Activity</h3><p>命令：</p>
<pre><code class="sh">adb shell dumpsys activity activities | grep mResumedActivity
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">mResumedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125;
</code></pre>
<p>其中的 <code>com.cyanogenmod.trebuchet/com.android.launcher3.Launcher</code> 就是当前处于前台的 Activity。</p>
<p><em>在 Windows 下以上命令可能不可用，可以尝试 <code>adb shell dumpsys activity activities | findstr mResumedActivity</code> 或 <code>adb shell &quot;dumpsys activity activities | grep mResumedActivity&quot;</code>。</em></p>
<h3 id="查看正在运行的-Services"><a href="#查看正在运行的-Services" class="headerlink" title="查看正在运行的 Services"></a>查看正在运行的 Services</h3><p>命令：</p>
<pre><code class="sh">adb shell dumpsys activity services [&lt;packagename&gt;]
</code></pre>
<p><code>&lt;packagename&gt;</code> 参数不是必须的，指定 <code>&lt;packagename&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</p>
<p><code>&lt;packagename&gt;</code> 不一定要给出完整的包名，比如运行 <code>adb shell dumpsys activity services org.mazhuang</code>，那么包名 <code>org.mazhuang.demo1</code>、<code>org.mazhuang.demo2</code> 和 <code>org.mazhuang123</code> 等相关的 Services 都会列出来。</p>
<h3 id="查看应用详细信息"><a href="#查看应用详细信息" class="headerlink" title="查看应用详细信息"></a>查看应用详细信息</h3><p>命令：</p>
<pre><code class="sh">adb shell dumpsys package &lt;packagename&gt;
</code></pre>
<p>输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p>
<p><code>&lt;packagename&gt;</code> 表示应用包名。</p>
<p>输出示例：</p>
<pre><code class="sh">Activity Resolver Table:
  Non-Data Actions:
      android.intent.action.MAIN:
        5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc
          Action: &quot;android.intent.action.MAIN&quot;
          Category: &quot;android.intent.category.LAUNCHER&quot;
          AutoVerify=false

Registered ContentProviders:
  org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider:
    Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;

ContentProvider Authorities:
  [org.mazhuang.guanggoo.fileProvider]:
    Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;
      applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;

Key Set Manager:
  [org.mazhuang.guanggoo]
      Signing KeySets: 501

Packages:
  Package [org.mazhuang.guanggoo] (c1d7f):
    userId=10394
    pkg=Package&#123;55f714c org.mazhuang.guanggoo&#125;
    codePath=/data/app/org.mazhuang.guanggoo-2
    resourcePath=/data/app/org.mazhuang.guanggoo-2
    legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib
    primaryCpuAbi=null
    secondaryCpuAbi=null
    versionCode=74 minSdk=15 targetSdk=25
    versionName=1.1.74
    splits=[base]
    apkSigningVersion=2
    applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;
    flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]
    privateFlags=[ RESIZEABLE_ACTIVITIES ]
    dataDir=/data/user/0/org.mazhuang.guanggoo
    supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity]
    timeStamp=2017-10-22 23:50:53
    firstInstallTime=2017-10-22 23:50:25
    lastUpdateTime=2017-10-22 23:50:55
    installerPackageName=com.miui.packageinstaller
    signatures=PackageSignatures&#123;af09595 [53c7caa2]&#125;
    installPermissionsFixed=true installStatus=1
    pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]
    requested permissions:
      android.permission.READ_PHONE_STATE
      android.permission.INTERNET
      android.permission.ACCESS_NETWORK_STATE
      android.permission.ACCESS_WIFI_STATE
      android.permission.READ_LOGS
      android.permission.WRITE_EXTERNAL_STORAGE
      android.permission.READ_EXTERNAL_STORAGE
    install permissions:
      android.permission.INTERNET: granted=true
      android.permission.ACCESS_NETWORK_STATE: granted=true
      android.permission.ACCESS_WIFI_STATE: granted=true
    User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0
      gids=[3003]
      runtime permissions:
        android.permission.READ_EXTERNAL_STORAGE: granted=true
        android.permission.READ_PHONE_STATE: granted=true
        android.permission.WRITE_EXTERNAL_STORAGE: granted=true
    User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0
      gids=[3003]
      runtime permissions:


Dexopt state:
  [org.mazhuang.guanggoo]
    Instruction Set: arm64
      path: /data/app/org.mazhuang.guanggoo-2/base.apk
      status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa
      te]
</code></pre>
<h3 id="查看应用安装路径"><a href="#查看应用安装路径" class="headerlink" title="查看应用安装路径"></a>查看应用安装路径</h3><p>命令:</p>
<pre><code>adb shell pm path &lt;PACKAGE&gt;
</code></pre>
<p>输出应用安装路径</p>
<p>输出示例:</p>
<pre><code>adb shell pm path ecarx.weather

package:/data/app/ecarx.weather-1.apk
</code></pre>
<h2 id="与应用交互"><a href="#与应用交互" class="headerlink" title="与应用交互"></a>与应用交互</h2><p>主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>start [options] </code></td>
<td>启动 `` 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] </code></td>
<td>启动 `` 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] </code></td>
<td>发送 `` 指定的广播</td>
</tr>
<tr>
<td><code>force-stop </code></td>
<td>停止 `` 相关的进程</td>
</tr>
</tbody></table>
<p><code>&lt;INTENT&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p>
<p>用于决定 intent 对象的选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-a </code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c </code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n </code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>com.example.app/.ExampleActivity</code></td>
</tr>
</tbody></table>
<p><code>&lt;INTENT&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>--esn </code></td>
<td>null 值（只有 key 名）</td>
</tr>
<tr>
<td>`-e</td>
<td>–es  `</td>
</tr>
<tr>
<td><code>--ez  </code></td>
<td>boolean 值</td>
</tr>
<tr>
<td><code>--ei  </code></td>
<td>integer 值</td>
</tr>
<tr>
<td><code>--el  </code></td>
<td>long 值</td>
</tr>
<tr>
<td><code>--ef  </code></td>
<td>float 值</td>
</tr>
<tr>
<td><code>--eu  </code></td>
<td>URI</td>
</tr>
<tr>
<td><code>--ecn  </code></td>
<td>component name</td>
</tr>
<tr>
<td>`–eia  [, [,</td>
<td></td>
</tr>
</tbody></table>
<h3 id="启动应用-调起-Activity"><a href="#启动应用-调起-Activity" class="headerlink" title="启动应用/ 调起 Activity"></a>启动应用/ 调起 Activity</h3><blockquote>
<p>指定Activity名称启动</p>
</blockquote>
<p>命令格式：</p>
<pre><code class="sh">adb shell am start [options] &lt;INTENT&gt;
</code></pre>
<p>例如：</p>
<pre><code class="sh">adb shell am start -n com.tencent.mm/.ui.LauncherUI
</code></pre>
<p>表示调起微信主界面。</p>
<pre><code class="sh">adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &quot;toast&quot; &quot;hello, world&quot;
</code></pre>
<p>表示调起 <code>org.mazhuang.boottimemeasure/.MainActivity</code> 并传给它 string 数据键值对 <code>toast - hello, world</code>。</p>
<blockquote>
<p>不指定Activity名称启动（启动主Activity）</p>
</blockquote>
<p>命令格式：</p>
<pre><code class="sh">adb shell monkey -p &lt;packagename&gt; -c android.intent.category.LAUNCHER 1
</code></pre>
<p>例如：</p>
<pre><code class="sh">adb shell monkey -p com.tencent.mm -c android.intent.category.LAUNCHER 1
</code></pre>
<p>表示调起微信主界面。</p>
<h3 id="调起-Service"><a href="#调起-Service" class="headerlink" title="调起 Service"></a>调起 Service</h3><p>命令格式：</p>
<pre><code class="sh">adb shell am startservice [options] &lt;INTENT&gt;
</code></pre>
<p>例如：</p>
<pre><code class="sh">adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService
</code></pre>
<p>表示调起微信的某 Service。</p>
<p>另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p>
<pre><code class="sh">adb shell am startservice -n com.android.systemui/.SystemUIService
</code></pre>
<h3 id="停止-Service"><a href="#停止-Service" class="headerlink" title="停止 Service"></a>停止 Service</h3><p>命令格式：</p>
<pre><code class="sh">adb shell am stopservice [options] &lt;INTENT&gt;
</code></pre>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>命令格式：</p>
<pre><code class="sh">adb shell am broadcast [options] &lt;INTENT&gt;
</code></pre>
<p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>例如，向所有组件广播 <code>BOOT_COMPLETED</code>：</p>
<pre><code class="sh">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED
</code></pre>
<p>又例如，只向 <code>org.mazhuang.boottimemeasure/.BootCompletedReceiver</code> 广播 <code>BOOT_COMPLETED</code>：</p>
<pre><code class="sh">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver
</code></pre>
<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。</p>
<p>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi 状态变为启用/关闭/正在启动/正在关闭/未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody></table>
<p><em>（以上广播均可使用 adb 触发）</em></p>
<h3 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h3><p>命令：</p>
<pre><code class="sh">adb shell am force-stop &lt;packagename&gt;
</code></pre>
<p>命令示例：</p>
<pre><code class="sh">adb shell am force-stop com.qihoo360.mobilesafe
</code></pre>
<p>表示停止 360 安全卫士的一切进程与服务。</p>
<h3 id="收紧内存"><a href="#收紧内存" class="headerlink" title="收紧内存"></a>收紧内存</h3><p>命令：</p>
<pre><code class="sh">adb shell am send-trim-memory  &lt;pid&gt; &lt;level&gt;
</code></pre>
<p>pid: 进程 ID<br>level:<br>HIDDEN、RUNNING_MODERATE、BACKGROUND、<br>RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE</p>
<p>命令示例：</p>
<pre><code class="sh">adb shell am send-trim-memory 12345 RUNNING_LOW
</code></pre>
<p>表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="复制设备里的文件到电脑"><a href="#复制设备里的文件到电脑" class="headerlink" title="复制设备里的文件到电脑"></a>复制设备里的文件到电脑</h3><p>命令：</p>
<pre><code class="sh">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]
</code></pre>
<p>其中 <code>电脑上的目录</code> 参数可以省略，默认复制到当前目录。</p>
<p>例：</p>
<pre><code class="sh">adb pull /sdcard/sr.mp4 ~/tmp/
</code></pre>
<p><em>小技巧：</em>设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 <code>adb shell</code> 和 <code>su</code> 命令在 adb shell 里获取 root 权限后，先 <code>cp /path/on/device /sdcard/filename</code> 将文件复制到 sdcard，然后 <code>adb pull /sdcard/filename /path/on/pc</code>。</p>
<h3 id="复制电脑里的文件到设备"><a href="#复制电脑里的文件到设备" class="headerlink" title="复制电脑里的文件到设备"></a>复制电脑里的文件到设备</h3><p>命令：</p>
<pre><code class="sh">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;
</code></pre>
<p>例：</p>
<pre><code class="sh">adb push ~/sr.mp4 /sdcard/
</code></pre>
<p><em>小技巧：</em>设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 <code>adb push /path/on/pc /sdcard/filename</code>，然后 <code>adb shell</code> 和 <code>su</code> 在 adb shell 里获取 root 权限后，<code>cp /sdcard/filename /path/on/device</code>。</p>
<h2 id="模拟按键-输入"><a href="#模拟按键-输入" class="headerlink" title="模拟按键/输入"></a>模拟按键/输入</h2><p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。</p>
<p><code>input</code> 命令的完整 help 信息如下：</p>
<pre><code class="sh">Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]

The sources are:
      mouse
      keyboard
      joystick
      touchnavigation
      touchpad
      trackball
      stylus
      dpad
      gesture
      touchscreen
      gamepad

The commands and default sources are:
      text &lt;string&gt; (Default: touchscreen)
      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)
      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)
      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)
      press (Default: trackball)
      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)
</code></pre>
<p>比如使用 <code>adb shell input keyevent &lt;keycode&gt;</code> 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 <a href="https://developer.android.com/reference/android/view/KeyEvent.html">KeyEvent</a>，摘引部分我觉得有意思的如下：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放/暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody></table>
<p>下面是 <code>input</code> 命令的一些用法举例。</p>
<h3 id="电源键"><a href="#电源键" class="headerlink" title="电源键"></a>电源键</h3><p>命令：</p>
<pre><code class="sh">adb shell input keyevent 26
</code></pre>
<p>执行效果相当于按电源键。</p>
<h3 id="菜单键"><a href="#菜单键" class="headerlink" title="菜单键"></a>菜单键</h3><p>命令：</p>
<pre><code class="sh">adb shell input keyevent 82
</code></pre>
<h3 id="HOME-键"><a href="#HOME-键" class="headerlink" title="HOME 键"></a>HOME 键</h3><p>命令：</p>
<pre><code class="sh">adb shell input keyevent 3
</code></pre>
<h3 id="返回键"><a href="#返回键" class="headerlink" title="返回键"></a>返回键</h3><p>命令：</p>
<pre><code class="sh">adb shell input keyevent 4
</code></pre>
<h3 id="音量控制"><a href="#音量控制" class="headerlink" title="音量控制"></a>音量控制</h3><p>增加音量：</p>
<pre><code class="sh">adb shell input keyevent 24
</code></pre>
<p>降低音量：</p>
<pre><code class="sh">adb shell input keyevent 25
</code></pre>
<p>静音：</p>
<pre><code class="sh">adb shell input keyevent 164
</code></pre>
<h3 id="媒体控制"><a href="#媒体控制" class="headerlink" title="媒体控制"></a>媒体控制</h3><p>播放/暂停：</p>
<pre><code class="sh">adb shell input keyevent 85
</code></pre>
<p>停止播放：</p>
<pre><code class="sh">adb shell input keyevent 86
</code></pre>
<p>播放下一首：</p>
<pre><code class="sh">adb shell input keyevent 87
</code></pre>
<p>播放上一首：</p>
<pre><code class="sh">adb shell input keyevent 88
</code></pre>
<p>恢复播放：</p>
<pre><code class="sh">adb shell input keyevent 126
</code></pre>
<p>暂停播放：</p>
<pre><code class="sh">adb shell input keyevent 127
</code></pre>
<h3 id="点亮-熄灭屏幕"><a href="#点亮-熄灭屏幕" class="headerlink" title="点亮/熄灭屏幕"></a>点亮/熄灭屏幕</h3><p>可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p>
<p>点亮屏幕：</p>
<pre><code class="sh">adb shell input keyevent 224
</code></pre>
<p>熄灭屏幕：</p>
<pre><code class="sh">adb shell input keyevent 223
</code></pre>
<h3 id="滑动解锁"><a href="#滑动解锁" class="headerlink" title="滑动解锁"></a>滑动解锁</h3><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。</p>
<p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<pre><code class="sh">adb shell input swipe 300 1000 300 500
</code></pre>
<p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p>
<p>命令：</p>
<pre><code class="sh">adb shell input text hello
</code></pre>
<p>现在 <code>hello</code> 出现在文本框了。</p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p>
<h3 id="Android-日志"><a href="#Android-日志" class="headerlink" title="Android 日志"></a>Android 日志</h3><p>命令格式：</p>
<pre><code class="sh">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...
</code></pre>
<p>常用用法列举如下：</p>
<h4 id="按级别过滤日志"><a href="#按级别过滤日志" class="headerlink" title="按级别过滤日志"></a>按级别过滤日志</h4><p>Android 的日志分为如下几个优先级（priority）：</p>
<ul>
<li>V —— Verbose（最低，输出得最多）</li>
<li>D —— Debug</li>
<li>I —— Info</li>
<li>W —— Warning</li>
<li>E —— Error</li>
<li>F —— Fatal</li>
<li>S —— Silent（最高，啥也不输出）</li>
</ul>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<pre><code class="sh">adb logcat *:W
</code></pre>
<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p>
<h4 id="按-tag-和级别过滤日志"><a href="#按-tag-和级别过滤日志" class="headerlink" title="按 tag 和级别过滤日志"></a>按 tag 和级别过滤日志</h4><p><code>&lt;filter-spec&gt;</code> 可以由多个 <code>&lt;tag&gt;[:priority]</code> 组成。</p>
<p>比如，命令：</p>
<pre><code class="sh">adb logcat ActivityManager:I MyApp:D *:S
</code></pre>
<p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p>
<ul>
<li>brief默认格式。格式为：<pre><code class="sh">&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;
</code></pre>
示例：<pre><code class="sh">D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>process格式为：<pre><code class="sh">&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;
</code></pre>
示例：<pre><code class="sh">D( 1785) Disconnected process message: 10, size: 0  (HeadsetStateMachine)
</code></pre>
</li>
<li>tag格式为：<pre><code class="sh">&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;
</code></pre>
示例：<pre><code class="sh">D/HeadsetStateMachine: Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>raw格式为：<pre><code class="sh">&lt;message&gt;
</code></pre>
示例：<pre><code class="sh">Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>time格式为：<pre><code class="sh">&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;
</code></pre>
示例：<pre><code class="sh">08-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>threadtime格式为：<pre><code class="sh">&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;
</code></pre>
示例：<pre><code class="sh">08-28 22:39:39.974  1785  1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>long格式为：<pre><code class="sh">[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]
&lt;message&gt;
</code></pre>
示例：<pre><code class="sh">[ 08-28 22:39:39.974  1785: 1832 D/HeadsetStateMachine ]
Disconnected process message: 10, size: 0
</code></pre>
</li>
</ul>
<p>指定格式可与上面的过滤同时使用。比如：</p>
<pre><code class="sh">adb logcat -v long ActivityManager:I *:S
</code></pre>
<h4 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h4><pre><code class="sh">adb logcat -c
</code></pre>
<h3 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h3><p>命令：</p>
<pre><code class="sh">adb shell dmesg
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs
&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs
&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs
&lt;4&gt;[14201.755954] Restarting tasks ... done.
&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC
&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC
&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done.
</code></pre>
<p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p>
<h2 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h2><h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><p>命令：</p>
<pre><code class="sh">adb shell getprop ro.product.model
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">Nexus 5
</code></pre>
<h3 id="电池状况"><a href="#电池状况" class="headerlink" title="电池状况"></a>电池状况</h3><p>命令：</p>
<pre><code class="sh">adb shell dumpsys battery
</code></pre>
<p>输入示例：</p>
<pre><code class="sh">Current Battery Service state:
  AC powered: false
  USB powered: true
  Wireless powered: false
  status: 2
  health: 2
  present: true
  level: 44
  scale: 100
  voltage: 3872
  temperature: 280
  technology: Li-poly
</code></pre>
<p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p>
<h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>命令：</p>
<pre><code class="sh">adb shell wm size
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">Physical size: 1080x1920
</code></pre>
<p>该设备屏幕分辨率为 1080px * 1920px。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<pre><code class="sh">Physical size: 1080x1920
Override size: 480x1024
</code></pre>
<p>表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。</p>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<pre><code class="sh">adb shell wm density
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">Physical density: 420
</code></pre>
<p>该设备屏幕密度为 420dpi。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<pre><code class="sh">Physical density: 480
Override density: 160
</code></pre>
<p>表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p>
<h3 id="显示屏参数"><a href="#显示屏参数" class="headerlink" title="显示屏参数"></a>显示屏参数</h3><p>命令：</p>
<pre><code class="sh">adb shell dumpsys window displays
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)
  Display: mDisplayId=0
    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731
    deferred=false layoutNeeded=false
</code></pre>
<p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</p>
<h3 id="android-id"><a href="#android-id" class="headerlink" title="android_id"></a>android_id</h3><p>命令：</p>
<pre><code class="sh">adb shell settings get secure android_id
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">51b6be48bac8c569
</code></pre>
<h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<pre><code class="sh">adb shell dumpsys iphonesubinfo
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">Phone Subscriber Info:
  Phone Type = GSM
  Device ID = 860955027785041
</code></pre>
<p>其中的 <code>Device ID</code> 就是 IMEI。</p>
<p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p>
<pre><code class="sh">adb shell
su
service call iphonesubinfo 1
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">Result: Parcel(
  0x00000000: 00000000 0000000f 00360038 00390030 &#39;........8.6.0.9.&#39;
  0x00000010: 00350035 00320030 00370037 00350038 &#39;5.5.0.2.7.7.8.5.&#39;
  0x00000020: 00340030 00000031                   &#39;0.4.1...        &#39;)
</code></pre>
<p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>860955027785041</code>。</p>
<p>参考：<a href="http://stackoverflow.com/questions/27002663/adb-shell-dumpsys-iphonesubinfo-not-working-since-android-5-0-lollipop">adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</a></p>
<h3 id="Android-系统版本"><a href="#Android-系统版本" class="headerlink" title="Android 系统版本"></a>Android 系统版本</h3><p>命令：</p>
<pre><code class="sh">adb shell getprop ro.build.version.release
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">5.0.2
</code></pre>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。</p>
<p>命令：</p>
<pre><code class="sh">adb shell ifconfig | grep Mask
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">inet addr:10.130.245.230  Mask:255.255.255.252
inet addr:127.0.0.1  Mask:255.0.0.0
</code></pre>
<p>那么 <code>10.130.245.230</code> 就是设备 IP 地址。</p>
<p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p>
<pre><code class="sh">adb shell ifconfig wlan0
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast]
</code></pre>
<p>或</p>
<pre><code class="sh">wlan0     Link encap:UNSPEC
          inet addr:10.129.168.57  Bcast:10.129.175.255  Mask:255.255.240.0
          inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:496520 errors:0 dropped:0 overruns:0 frame:0
          TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:3000
          RX bytes:116266821 TX bytes:8311736
</code></pre>
<p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p>
<pre><code class="sh">adb shell netcfg
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">wlan0    UP                               10.129.160.99/20  0x00001043 f8:a9:d0:17:42:4d
lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00
p2p0     UP                                     0.0.0.0/0   0x00001003 fa:a9:d0:17:42:4d
sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00
rmnet0   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet1   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet3   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet2   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet4   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet6   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet5   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet7   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rev_rmnet3 DOWN                                   0.0.0.0/0   0x00001002 4e:b7:e4:2e:17:58
rev_rmnet2 DOWN                                   0.0.0.0/0   0x00001002 4e:f0:c8:bf:7a:cf
rev_rmnet4 DOWN                                   0.0.0.0/0   0x00001002 a6:c0:3b:6b:c4:1f
rev_rmnet6 DOWN                                   0.0.0.0/0   0x00001002 66:bb:5d:64:2e:e9
rev_rmnet5 DOWN                                   0.0.0.0/0   0x00001002 0e:1b:eb:b9:23:a0
rev_rmnet7 DOWN                                   0.0.0.0/0   0x00001002 7a:d9:f6:81:40:5a
rev_rmnet8 DOWN                                   0.0.0.0/0   0x00001002 4e:e2:a9:bb:d0:1b
rev_rmnet0 DOWN                                   0.0.0.0/0   0x00001002 fe:65:d0:ca:82:a9
rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 da:d8:e8:4f:2e:fe
</code></pre>
<p>可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。</p>
<h3 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h3><p>命令：</p>
<pre><code class="sh">adb shell cat /sys/class/net/wlan0/address
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">f8:a9:d0:17:42:4d
</code></pre>
<p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p>
<h3 id="CPU-信息"><a href="#CPU-信息" class="headerlink" title="CPU 信息"></a>CPU 信息</h3><p>命令：</p>
<pre><code class="sh">adb shell cat /proc/cpuinfo
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">Processor       : ARMv7 Processor rev 0 (v7l)
processor       : 0
BogoMIPS        : 38.40

processor       : 1
BogoMIPS        : 38.40

processor       : 2
BogoMIPS        : 38.40

processor       : 3
BogoMIPS        : 38.40

Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt
CPU implementer : 0x51
CPU architecture: 7
CPU variant     : 0x2
CPU part        : 0x06f
CPU revision    : 0

Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)
Revision        : 000b
Serial          : 0000000000000000
</code></pre>
<p>这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 <code>Qualcomm MSM 8974</code>，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 <code>ARMv7 Processor rev 0 (v71)</code>。</p>
<h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><p>命令：</p>
<pre><code class="sh">adb shell cat /proc/meminfo
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">MemTotal:        1027424 kB
MemFree:          486564 kB
Buffers:           15224 kB
Cached:            72464 kB
SwapCached:        24152 kB
Active:           110572 kB
Inactive:         259060 kB
Active(anon):      79176 kB
Inactive(anon):   207736 kB
Active(file):      31396 kB
Inactive(file):    51324 kB
Unevictable:        3948 kB
Mlocked:               0 kB
HighTotal:        409600 kB
HighFree:         132612 kB
LowTotal:         617824 kB
LowFree:          353952 kB
SwapTotal:        262140 kB
SwapFree:         207572 kB
Dirty:                 0 kB
Writeback:             0 kB
AnonPages:        265324 kB
Mapped:            47072 kB
Shmem:              1020 kB
Slab:              57372 kB
SReclaimable:       7692 kB
SUnreclaim:        49680 kB
KernelStack:        4512 kB
PageTables:         5912 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:      775852 kB
Committed_AS:   13520632 kB
VmallocTotal:     385024 kB
VmallocUsed:       61004 kB
VmallocChunk:     209668 kB
</code></pre>
<p>其中，<code>MemTotal</code> 就是设备的总内存，<code>MemFree</code> 是当前空闲内存。</p>
<h3 id="更多硬件与系统属性"><a href="#更多硬件与系统属性" class="headerlink" title="更多硬件与系统属性"></a>更多硬件与系统属性</h3><p>设备的更多硬件与系统属性可以通过如下命令查看：</p>
<pre><code class="sh">adb shell cat /system/build.prop
</code></pre>
<p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p>
<p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td>ro.product.name</td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表[<em>节注一</em>]</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody></table>
<p><em>节注一：</em></p>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p>
<pre><code class="sh">adb shell cat /system/build.prop | grep ro.product.cpu.abi
</code></pre>
<p>示例输出：</p>
<pre><code class="sh">ro.product.cpu.abi=armeabi-v7a
ro.product.cpu.abi2=armeabi
</code></pre>
<h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p>
<p>修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>命令：</p>
<pre><code class="sh">adb shell wm size 480x1024
</code></pre>
<p>表示将分辨率修改为 480px * 1024px。</p>
<p>恢复原分辨率命令：</p>
<pre><code class="sh">adb shell wm size reset
</code></pre>
<h3 id="屏幕密度-1"><a href="#屏幕密度-1" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<pre><code class="sh">adb shell wm density 160
</code></pre>
<p>表示将屏幕密度修改为 160dpi。</p>
<p>恢复原屏幕密度命令：</p>
<pre><code class="sh">adb shell wm density reset
</code></pre>
<h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><p>命令：</p>
<pre><code class="sh">adb shell wm overscan 0,0,0,200
</code></pre>
<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p>
<p>恢复原显示区域命令：</p>
<pre><code class="sh">adb shell wm overscan reset
</code></pre>
<h3 id="关闭-USB-调试模式"><a href="#关闭-USB-调试模式" class="headerlink" title="关闭 USB 调试模式"></a>关闭 USB 调试模式</h3><p>命令：</p>
<pre><code class="sh">adb shell settings put global adb_enabled 0
</code></pre>
<p>恢复：</p>
<p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。</p>
<p>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h3 id="允许-禁止访问非-SDK-API"><a href="#允许-禁止访问非-SDK-API" class="headerlink" title="允许/禁止访问非 SDK API"></a>允许/禁止访问非 SDK API</h3><p>允许访问非 SDK API：</p>
<pre><code class="sh">adb shell settings put global hidden_api_policy_pre_p_apps 1
adb shell settings put global hidden_api_policy_p_apps 1
</code></pre>
<p>禁止访问非 SDK API：</p>
<pre><code class="sh">adb shell settings delete global hidden_api_policy_pre_p_apps
adb shell settings delete global hidden_api_policy_p_apps
</code></pre>
<p>不需要设备获得 Root 权限。</p>
<p>命令最后的数字的含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td>
</tr>
<tr>
<td>1</td>
<td>仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td>
</tr>
<tr>
<td>2</td>
<td>禁止调用深灰名单和黑名单中的接口。</td>
</tr>
<tr>
<td>3</td>
<td>禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td>
</tr>
</tbody></table>
<h3 id="状态栏和导航栏的显示隐藏"><a href="#状态栏和导航栏的显示隐藏" class="headerlink" title="状态栏和导航栏的显示隐藏"></a>状态栏和导航栏的显示隐藏</h3><p>本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p>
<p>命令：</p>
<pre><code class="sh">adb shell settings put global policy_control &lt;key-values&gt;
</code></pre>
<p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody></table>
<p>这些键对应的值可则如下值用逗号组合：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>apps</code></td>
<td>所有应用</td>
</tr>
<tr>
<td><code>*</code></td>
<td>所有界面</td>
</tr>
<tr>
<td><code>packagename</code></td>
<td>指定应用</td>
</tr>
<tr>
<td><code>-packagename</code></td>
<td>排除指定应用</td>
</tr>
</tbody></table>
<p>例如：</p>
<pre><code class="sh">adb shell settings put global policy_control immersive.full=*
</code></pre>
<p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<pre><code class="sh">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3
</code></pre>
<p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p>
<h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p>截图保存到电脑：</p>
<pre><code class="sh">adb exec-out screencap -p &gt; sc.png
</code></pre>
<p>如果 adb 版本较老，无法使用 <code>exec-out</code> 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p>
<p>先截图保存到设备里：</p>
<pre><code class="sh">adb shell screencap -p /sdcard/sc.png
</code></pre>
<p>然后将 png 文件导出到电脑：</p>
<pre><code class="sh">adb pull /sdcard/sc.png
</code></pre>
<p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody></table>
<p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>另外一种一行命令截图并保存到电脑的方法：</p>
<p><em>Linux 和 Windows</em></p>
<pre><code class="sh">adb shell screencap -p | sed &quot;s/\r$//&quot; &gt; sc.png
</code></pre>
<p><em>Mac OS X</em></p>
<pre><code class="sh">adb shell screencap -p | gsed &quot;s/\r$//&quot; &gt; sc.png
</code></pre>
<p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：</p>
<pre><code class="sh">sed: RE error: illegal byte sequence
</code></pre>
<p>需要安装 gnu-sed，然后使用 gsed 命令：</p>
<pre><code class="sh">brew install gnu-sed
</code></pre>
<h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p>录制屏幕以 mp4 格式保存到 /sdcard：</p>
<pre><code class="sh">adb shell screenrecord /sdcard/filename.mp4
</code></pre>
<p>需要停止时按 <kbd>Ctrl-C</kbd>，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：</p>
<pre><code class="sh">adb pull /sdcard/filename.mp4
</code></pre>
<p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody></table>
<h3 id="重新挂载-system-分区为可写"><a href="#重新挂载-system-分区为可写" class="headerlink" title="重新挂载 system 分区为可写"></a>重新挂载 system 分区为可写</h3><p><strong>注：需要 root 权限。</strong></p>
<p>/system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。</p>
<p>步骤：</p>
<ol>
<li>进入 shell 并切换到 root 用户权限。命令：<pre><code class="sh">adb shell
su
</code></pre>
</li>
<li>查看当前分区挂载情况。命令：<pre><code class="sh">mount
</code></pre>
输出示例：<pre><code class="sh">rootfs / rootfs ro,relatime 0 0
tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0
devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0
proc /proc proc rw,relatime 0 0
sysfs /sys sysfs rw,seclabel,relatime 0 0
selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0
debugfs /sys/kernel/debug debugfs rw,relatime 0 0
none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0
none /acct cgroup rw,relatime,cpuacct 0 0
none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0
none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0
tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0
tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0
none /dev/memcg cgroup rw,relatime,memory 0 0
none /dev/cpuctl cgroup rw,relatime,cpu 0 0
none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0
none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0
none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0
/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0
/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0
/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0
</code></pre>
找到其中我们关注的带 /system 的那一行：<pre><code class="sh">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0
</code></pre>
</li>
<li>重新挂载。命令：<pre><code class="sh">mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system
</code></pre>
这里的 <code>/dev/block/platform/msm_sdcc.1/by-name/system</code> 就是我们从上一步的输出里得到的文件路径。</li>
</ol>
<p>如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。</p>
<h3 id="查看连接过的-WiFi-密码"><a href="#查看连接过的-WiFi-密码" class="headerlink" title="查看连接过的 WiFi 密码"></a>查看连接过的 WiFi 密码</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<pre><code class="sh">adb shell
su
cat /data/misc/wifi/*.conf
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">network=&#123;
    ssid=&quot;TP-LINK_9DFC&quot;
    scan_ssid=1
    psk=&quot;123456789&quot;
    key_mgmt=WPA-PSK
    group=CCMP TKIP
    auth_alg=OPEN
    sim_num=1
    priority=13893
&#125;

network=&#123;
    ssid=&quot;TP-LINK_F11E&quot;
    psk=&quot;987654321&quot;
    key_mgmt=WPA-PSK
    sim_num=1
    priority=17293
&#125;
</code></pre>
<p><code>ssid</code> 即为我们在 WLAN 设置里看到的名称，<code>psk</code> 为密码，<code>key_mgmt</code> 为安全加密方式。</p>
<p>如果 Android O 或以后，WiFi 密码保存的地址有变化，是在 <code>WifiConfigStore.xml</code> 里面</p>
<pre><code class="sh">adb shell
su
cat /data/misc/wifi/WifiConfigStore.xml
</code></pre>
<p>输出格式：</p>
<p>数据项较多，只需关注 <code>ConfigKey</code>（WiFi 名字）和 <code>PreSharedKey</code>（WiFi 密码）即可</p>
<pre><code class="xml">&lt;string name=&quot;ConfigKey&quot;&gt;&amp;quot;Wi-Fi&amp;quot;WPA_PSK&lt;/string&gt;
&lt;string name=&quot;PreSharedKey&quot;&gt;&amp;quot;931907334&amp;quot;&lt;/string&gt;
</code></pre>
<h3 id="设置系统日期和时间"><a href="#设置系统日期和时间" class="headerlink" title="设置系统日期和时间"></a>设置系统日期和时间</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<pre><code class="sh">adb shell
su
date -s 20160823.131500
</code></pre>
<p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p>
<h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><p>命令：</p>
<pre><code class="sh">adb reboot
</code></pre>
<h3 id="检测设备是否已-root"><a href="#检测设备是否已-root" class="headerlink" title="检测设备是否已 root"></a>检测设备是否已 root</h3><p>命令：</p>
<pre><code class="sh">adb shell
su
</code></pre>
<p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p>
<h3 id="使用-Monkey-进行压力测试"><a href="#使用-Monkey-进行压力测试" class="headerlink" title="使用 Monkey 进行压力测试"></a>使用 Monkey 进行压力测试</h3><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<pre><code class="sh">adb shell monkey -p &lt;packagename&gt; -v 500
</code></pre>
<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。</p>
<p>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html">官方文档</a>。</p>
<h3 id="开启-关闭-WiFi"><a href="#开启-关闭-WiFi" class="headerlink" title="开启/关闭 WiFi"></a>开启/关闭 WiFi</h3><p><strong>注：需要 root 权限。</strong></p>
<p>有时需要控制设备的 WiFi 状态，可以用以下指令完成。</p>
<p>开启 WiFi：</p>
<pre><code class="sh">adb root
adb shell svc wifi enable
</code></pre>
<p>关闭 WiFi：</p>
<pre><code class="sh">adb root
adb shell svc wifi disable
</code></pre>
<p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p>
<h2 id="刷机相关命令"><a href="#刷机相关命令" class="headerlink" title="刷机相关命令"></a>刷机相关命令</h2><h3 id="重启到-Recovery-模式"><a href="#重启到-Recovery-模式" class="headerlink" title="重启到 Recovery 模式"></a>重启到 Recovery 模式</h3><p>命令：</p>
<pre><code class="sh">adb reboot recovery
</code></pre>
<h3 id="从-Recovery-重启到-Android"><a href="#从-Recovery-重启到-Android" class="headerlink" title="从 Recovery 重启到 Android"></a>从 Recovery 重启到 Android</h3><p>命令：</p>
<pre><code class="sh">adb reboot
</code></pre>
<h3 id="重启到-Fastboot-模式"><a href="#重启到-Fastboot-模式" class="headerlink" title="重启到 Fastboot 模式"></a>重启到 Fastboot 模式</h3><p>命令：</p>
<pre><code class="sh">adb reboot bootloader
</code></pre>
<h3 id="通过-sideload-更新系统"><a href="#通过-sideload-更新系统" class="headerlink" title="通过 sideload 更新系统"></a>通过 sideload 更新系统</h3><p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<ol>
<li>重启到 Recovery 模式。命令：<pre><code class="sh">adb reboot recovery
</code></pre>
</li>
<li>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</li>
<li>通过 adb 上传和更新系统。命令：<pre><code class="sh">adb sideload &lt;path-to-update.zip&gt;
</code></pre>
</li>
</ol>
<h2 id="安全相关命令"><a href="#安全相关命令" class="headerlink" title="安全相关命令"></a>安全相关命令</h2><h3 id="启用-禁用-SELinux"><a href="#启用-禁用-SELinux" class="headerlink" title="启用/禁用 SELinux"></a>启用/禁用 SELinux</h3><p>启用 SELinux</p>
<pre><code class="sh">adb root
adb shell setenforce 1
</code></pre>
<p>禁用 SELinux</p>
<pre><code class="sh">adb root
adb shell setenforce 0
</code></pre>
<h3 id="启用-禁用-dm-verity"><a href="#启用-禁用-dm-verity" class="headerlink" title="启用/禁用 dm_verity"></a>启用/禁用 dm_verity</h3><p>启用 dm_verity</p>
<pre><code class="sh">adb root
adb enable-verity
</code></pre>
<p>禁用 dm_verity</p>
<pre><code class="sh">adb root
adb disable-verity
</code></pre>
<h2 id="更多-adb-shell-命令"><a href="#更多-adb-shell-命令" class="headerlink" title="更多 adb shell 命令"></a>更多 adb shell 命令</h2><p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>命令：</p>
<pre><code class="sh">adb shell ps
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME
root      1     0     8904   788   ffffffff 00000000 S /init
root      2     0     0      0     ffffffff 00000000 S kthreadd
...
u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic
u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure
...
shell     8750  217   10640  740   00000000 b6f28340 R ps
</code></pre>
<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<h3 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h3><p>命令：</p>
<pre><code class="sh">adb shell top
</code></pre>
<p>输出示例：</p>
<pre><code class="sh">User 0%, System 6%, IOW 0%, IRQ 0%
User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307

  PID PR CPU% S  #THR     VSS     RSS PCY UID      Name
 8763  0   3% R     1  10640K   1064K  fg shell    top
  131  0   3% S     1      0K      0K  fg root     dhd_dpc
 6144  0   0% S   115 1682004K 115916K  fg system   system_server
  132  0   0% S     1      0K      0K  fg root     dhd_rxf
 1731  0   0% S     6  20288K    788K  fg root     /system/bin/mpdecision
  217  0   0% S     6  18008K    356K  fg shell    /sbin/adbd
 ...
 7779  2   0% S    19 1538748K  48896K  bg u0_a71   com.sohu.inputmethod.sogou:classic
 7963  0   0% S    18 1561916K  59568K  fg u0_a58   org.mazhuang.boottimemeasure
 ...
</code></pre>
<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND/SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<p><code>top</code> 命令还支持一些命令行参数，详细用法如下：</p>
<pre><code class="sh">Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]
    -m num  最多显示多少个进程
    -n num  刷新多少次后退出
    -d num  刷新时间间隔（单位秒，默认值 5）
    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）
    -t      显示线程信息
    -h      显示帮助文档
</code></pre>
<h3 id="查看进程-UID"><a href="#查看进程-UID" class="headerlink" title="查看进程 UID"></a>查看进程 UID</h3><p>有两种方案：</p>
<ol>
<li><code>adb shell dumpsys package &lt;packagename&gt; | grep userId=</code>如：<pre><code class="sh">$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId=
   userId=10394
</code></pre>
</li>
<li>通过 ps 命令找到对应进程的 pid 之后 <code>adb shell cat /proc/&lt;pid&gt;/status | grep Uid</code>如：<pre><code class="sh">$ adb shell
gemini:/ $ ps | grep org.mazhuang.guanggoo
u0_a394   28635 770   1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoo
gemini:/ $ cat /proc/28635/status | grep Uid
Uid:    10394   10394   10394   10394
gemini:/ $
</code></pre>
</li>
</ol>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cat</td>
<td>显示文件内容</td>
</tr>
<tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件的存取模式/访问权限</td>
</tr>
<tr>
<td>df</td>
<td>查看磁盘空间使用情况</td>
</tr>
<tr>
<td>grep</td>
<td>过滤输出</td>
</tr>
<tr>
<td>kill</td>
<td>杀死指定 PID 的进程</td>
</tr>
<tr>
<td>ls</td>
<td>列举目录内容</td>
</tr>
<tr>
<td>mount</td>
<td>挂载目录的查看和管理</td>
</tr>
<tr>
<td>mv</td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>ps</td>
<td>查看正在运行的进程</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>top</td>
<td>查看进程的资源占用情况</td>
</tr>
</tbody></table>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="启动-adb-server-失败"><a href="#启动-adb-server-失败" class="headerlink" title="启动 adb server 失败"></a>启动 adb server 失败</h3><p><strong>出错提示</strong></p>
<pre><code class="sh">error: protocol fault (couldn&#39;t read status): No error
</code></pre>
<p><strong>可能原因</strong></p>
<p>adb server 进程想使用的 5037 端口被占用。</p>
<p><strong>解决方案</strong></p>
<p>找到占用 5037 端口的进程，然后终止它。以 Windows 下为例：</p>
<pre><code class="sh">netstat -ano | findstr LISTENING

...
TCP    0.0.0.0:5037           0.0.0.0:0              LISTENING       1548
...
</code></pre>
<p>这里 1548 即为进程 ID，用命令结束该进程：</p>
<pre><code class="sh">taskkill /PID 1548
</code></pre>
<p>然后再启动 adb 就没问题了。</p>
<h3 id="com-android-ddmlib-AdbCommandRejectedException"><a href="#com-android-ddmlib-AdbCommandRejectedException" class="headerlink" title="com.android.ddmlib.AdbCommandRejectedException"></a>com.android.ddmlib.AdbCommandRejectedException</h3><p>在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示：</p>
<pre><code>com.android.ddmlib.AdbCommandRejectedException: device unauthorized.
This adb server&#39;s $ADB_VENDOR_KEYS is not set
Try &#39;adb kill-server&#39; if that seems wrong.
Otherwise check for a confirmation dialog on your device.
</code></pre>
<p>在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。</p>
<p>于是删除该模拟器后重新下载安装一次，这次就正常了。</p>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
  </entry>
  <entry>
    <title>使用cloudflare为博客域名添加https支持</title>
    <url>/p/c2f948cd/</url>
    <content><![CDATA[<p>该教程的前提是已经为Github Pages 绑定上了域名。</p>
<span id="more"></span>
<h2 id="替换域名供应商解析的ddns为cloudflare提供的ddns"><a href="#替换域名供应商解析的ddns为cloudflare提供的ddns" class="headerlink" title="替换域名供应商解析的ddns为cloudflare提供的ddns"></a>替换域名供应商解析的ddns为cloudflare提供的ddns</h2><h2 id="ddns规则"><a href="#ddns规则" class="headerlink" title="ddns规则"></a>ddns规则</h2><p><img src="https://mapp.alicdn.com/1637908435505pPBvxRE7rVw3scH.png" alt="ddns"></p>
<h2 id="将Cloudflare的SSL-encryption-mode-设置为Flexible"><a href="#将Cloudflare的SSL-encryption-mode-设置为Flexible" class="headerlink" title="将Cloudflare的SSL encryption mode 设置为Flexible"></a>将Cloudflare的SSL encryption mode 设置为Flexible</h2><p><img src="https://mapp.alicdn.com/1637908592306nJxj2mI5hIJvhMF.png" alt="SSL Encryption Mode"></p>
<h2 id="Cloudfalre-Rules-PageRules-添加规则"><a href="#Cloudfalre-Rules-PageRules-添加规则" class="headerlink" title="Cloudfalre Rules PageRules 添加规则"></a>Cloudfalre Rules PageRules 添加规则</h2><p><img src="https://mapp.alicdn.com/1637907912856hyCJGUArzZLh0W2.png" alt="PageRules"></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>开发环境篇之windows一键切换jdk</title>
    <url>/p/ccb8e643/</url>
    <content><![CDATA[<p>本人常用jdk版本为1.8 以及 17。当电脑上有多个jdk版本时，一键切换则非常有必要。</p>
<p>jdk各个版本的下载：<a href="https://www.oracle.com/technetwork/java/javase/archive-139210.html" title="https://www.oracle.com/technetwork/java/javase/archive-139210.html">https://www.oracle.com/technetwork/java/javase/archive-139210.html</a></p>
<p><strong>注意：</strong></p>
<ul>
<li>复制保存编码格式为 ANSI，后缀bat</li>
<li>变量 JAVA_PATH 中 javapath 文件夹可能需要手动创建</li>
<li>各版本的 jdk 路径需要手动替换</li>
<li>右键管理员运行</li>
</ul>
<pre><code class="bat">@echo off
rem 切换Java jdk版本
echo 请以管理员来进行切换
java -version
 
:menu
echo =============================================
echo 请选择要切换的jdk版本
echo 1：Java jdk 17
echo 2：Java jdk 1.8
echo 3: 取消
echo =============================================
set /p ch=请选择：
if &quot;%ch%&quot;==&quot;1&quot; goto java17
if &quot;%ch%&quot;==&quot;2&quot; goto java1.8
if &quot;%ch%&quot;==&quot;3&quot; goto exit
goto menu
 
 
:java17
set JAVA_HOME=D:\programs\jdk-17.0.5
@REM set JRE_HOME=C:\Program Files\Java\jdk-17.0.2
set JAVA_VERSION=17
goto exec
 
 
:java1.8
set JAVA_HOME=D:\Environment\Java\jdk1.8.0_331
@REM set JRE_HOME=C:\Program Files\Java\jre1.8.0_131
set JAVA_VERSION=1.8
goto exec
 
:exec
reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Development Kit&quot; /v CurrentVersion /t REG_SZ /f /d &quot;%JAVA_VERSION%&quot;
reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment&quot; /v CurrentVersion /t REG_SZ /f /d &quot;%JAVA_VERSION%&quot;
reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment&quot; /v JAVA_HOME /t REG_SZ /f /d &quot;%JAVA_HOME%&quot;
@REM reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment&quot; /v JRE_HOME /t REG_SZ /f /d &quot;%JRE_HOME%&quot;
del /f &quot;C:\Windows\System32\java.exe&quot;
copy /Y &quot;%JAVA_HOME%\bin\java.exe&quot; &quot;C:\Windows\System32\java.exe&quot;
del /f &quot;C:\Windows\System32\javaw.exe&quot;
copy /Y &quot;%JAVA_HOME%\bin\javaw.exe&quot; &quot;C:\Windows\System32\javaw.exe&quot;
del /f &quot;C:\Windows\System32\javaws.exe&quot;
copy /Y &quot;%JAVA_HOME%\bin\javaws.exe&quot; &quot;C:\Windows\System32\javaws.exe&quot;
set JAVA_PATH=C:\ProgramData\Oracle\Java\javapath
del /f &quot;%JAVA_PATH%\java.exe&quot;
mklink &quot;%JAVA_PATH%\java.exe&quot; &quot;%JAVA_HOME%\bin\java.exe&quot;
del /f &quot;%JAVA_PATH%\javaw.exe&quot;
mklink &quot;%JAVA_PATH%\javaw.exe&quot; &quot;%JAVA_HOME%\bin\javaw.exe&quot;
del /f &quot;%JAVA_PATH%\javaws.exe&quot;
mklink &quot;%JAVA_PATH%\javaws.exe&quot; &quot;%JAVA_HOME%\bin\javaws.exe&quot;
echo 已切换到JDK %JAVA_VERSION%
pause
goto exit
:exit
</code></pre>
]]></content>
      <tags>
        <tag>dev</tag>
        <tag>windows</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 使用记录</title>
    <url>/p/9e7634f3/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/docker/docker-install">官方安装</a></p>
<pre><code>curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh
</code></pre>
<p><a href="https://github.com/EdNovas/vpstoolbox">一键脚本工具箱</a></p>
<pre><code>wget -N https://cdn.jsdelivr.net/gh/ednovas/vpstoolbox@main/ednovastool.sh &amp;&amp; sh ednovastool.sh
</code></pre>
<h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><p>centos 安装</p>
<pre><code>yum install -y docker-compose
</code></pre>
<p>注：docker-compose基于docker，版本要匹配。不建议通过源码安装，这样可以导致版本不匹配。</p>
<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><pre><code>$ docker pull image_name:image_version//eg:ruby:2.1
</code></pre>
<h4 id="查看下载过的images"><a href="#查看下载过的images" class="headerlink" title="查看下载过的images"></a>查看下载过的images</h4><pre><code>$ docker images
</code></pre>
<h4 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h4><pre><code>//--name为指定缩略名，下次可直接用docker start启动，-d为运行后进入实例，-p为指定端口映射
$ docker run --name &quot;oc&quot; -d -p 80:80 owncloud:9
//以后就可以使用缩略名启动
$ docker stop oc
$ docker start oc
</code></pre>
<h4 id="查看Docker运行的实例"><a href="#查看Docker运行的实例" class="headerlink" title="查看Docker运行的实例"></a>查看Docker运行的实例</h4><pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
87289a2598e7        owncloud:9          &quot;/entrypoint.sh apach&quot;   About an hour ago   Up About an hour    0.0.0.0:80-&gt;80/tcp   oc
1305
</code></pre>
<h4 id="进入Docker实例"><a href="#进入Docker实例" class="headerlink" title="进入Docker实例"></a>进入Docker实例</h4><pre><code>//查看PID,
$ docker inspect --format &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; 87289a2598e7
//进入PID对应的Container实例
$ nsenter --target 1305 --mount --uts --ipc --net --pid
</code></pre>
<h4 id="停止Docker容器"><a href="#停止Docker容器" class="headerlink" title="停止Docker容器"></a>停止Docker容器</h4><pre><code>//通过ps获得所有运行的容器和对应的ID
$ docker ps
//指定ID进行停止
$ docker stop 87289a2598e7
//也可以指定name停止
$ docker stop oc
</code></pre>
<h4 id="删除Docker容器"><a href="#删除Docker容器" class="headerlink" title="删除Docker容器"></a>删除Docker容器</h4><pre><code>$ docker rm 87289a2598e7
//或者指定name进行容器删除
$ docker rm oc
</code></pre>
<h4 id="删除Docker镜像"><a href="#删除Docker镜像" class="headerlink" title="删除Docker镜像"></a>删除Docker镜像</h4><pre><code>$ docker rmi owncloud:9
</code></pre>
<h4 id="修改容器并提交"><a href="#修改容器并提交" class="headerlink" title="修改容器并提交"></a>修改容器并提交</h4><pre><code>//首先进入容器
//然后进行修改,增加ldap认证支持
//进入PID对应的容器
$ nsenter --target 1305 --mount --uts --ipc --net --pid
//更新源
# apt-get update
//安装需要的组件
# apt-get install libldap2-dev
# docker-php-ext-configure ldap --with-libdir=lib/x86_64-linux-gnu
# docker-php-ext-install ldap
//退出容器
# exit
//提交对容器的修改
$ docker commit 87289a2598e7 owncloud/ldap
//重启容器
$ docker stop oc
$ docker run --name ocldap -d -p 80:80 owncloud/ldap
</code></pre>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Excel转Android字符串资源脚本</title>
    <url>/p/4c6327d2/</url>
    <content><![CDATA[<h1 id="Excel转Android字符串资源脚本"><a href="#Excel转Android字符串资源脚本" class="headerlink" title="Excel转Android字符串资源脚本"></a>Excel转Android字符串资源脚本</h1><p>该脚本可以将 Excel 文件中的数据转换为 Android 字符串资源文件。</p>
<p>文件名：<code>excel_to_android_strings.py</code></p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol>
<li><p><strong>安装依赖</strong><br>请确保已安装以下依赖：</p>
<ul>
<li>Python 3.x</li>
<li>pandas 库</li>
</ul>
<p>安装 pandas 库：</p>
<pre><code>pip install pandas
</code></pre>
</li>
<li><p><strong>运行脚本</strong><br>在命令行中运行脚本，并提供 Excel 文件的路径。你可以选择提供一个输出目录，如果未提供，默认在当前目录下生成 Android 字符串资源文件。</p>
<pre><code class="bash">python excel_to_android_strings.py path_to_excel_file.xlsx --output-dir path_to_output_directory
</code></pre>
<p>将 <code>path_to_excel_file.xlsx</code> 替换为你的 Excel 文件的路径，将 <code>path_to_output_directory</code> 替换为你想要生成 Android 字符串文件的目录。</p>
</li>
</ol>
<h2 id="Excel-文件格式"><a href="#Excel-文件格式" class="headerlink" title="Excel 文件格式"></a>Excel 文件格式</h2><p>Excel 文件应包含以下内容：</p>
<ul>
<li>第一行应为标题行，指定每列的含义。</li>
<li>第一列应该是键（key），后续列是对应语言的翻译。键是字符串资源在 Android 代码中的标识符。</li>
<li>使用第一行的标题来指定每一列的语言。</li>
</ul>
<p>示例：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>en</th>
<th>zh</th>
<th>fr</th>
</tr>
</thead>
<tbody><tr>
<td>hello</td>
<td>Hello</td>
<td>你好</td>
<td>Bonjour</td>
</tr>
<tr>
<td>goodbye</td>
<td>Goodbye</td>
<td>再见</td>
<td>Au revoir</td>
</tr>
<tr>
<td>welcome</td>
<td>Welcome</td>
<td>欢迎</td>
<td>Bienvenue</td>
</tr>
</tbody></table>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>脚本将根据 Excel 文件的内容在指定的输出目录中生成对应的 Android 字符串资源文件（<code>strings.xml</code>）。每个语言的字符串资源将存储在单独的文件中，并以该语言的标识符命名。例如，<code>strings_en.xml</code> 包含英文字符串资源，<code>strings_zh.xml</code> 包含中文字符串资源，以此类推。</p>
]]></content>
      <categories>
        <category>Script</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>frida 使用</title>
    <url>/p/a46beb02/</url>
    <content><![CDATA[<h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><ul>
<li>客户端：windows 10</li>
<li>服务端：Android 10</li>
</ul>
<h2 id="window-10"><a href="#window-10" class="headerlink" title="window 10"></a>window 10</h2><p>windows 安装 pyhon37,打开cmd，使用命令</p>
<pre><code>pip install frida
pip install frida-tools
</code></pre>
<h2 id="android-10"><a href="#android-10" class="headerlink" title="android 10"></a>android 10</h2><p>查看Android手机 cpu 架构设置<code>getprop ro.product.cpu.abi</code></p>
]]></content>
  </entry>
  <entry>
    <title>使用 frp 实现内网穿透</title>
    <url>/p/6588bb8d/</url>
    <content><![CDATA[<h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><ul>
<li><p>服务端：<a href="https://www.aliyun.com/acts/hotsale?userCode=hx8yc2tz">阿里云服务器ECS</a>：配置：1核 2GB ，40G云盘，1Mbps带宽，操作系统  CentOS Linux release 8.3.2011</p>
</li>
<li><p>客户端：黑群辉 虚拟机 windows 7</p>
</li>
<li><p><a href="https://github.com/fatedier/frp/releases">Frp</a>。frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。阿里云服务器使用的版本是：frp_0.31.1_linux_amd64.tar.gz。Windows电脑使用的版本是：frp_0.31.1_windows_amd64.zip。</p>
</li>
<li><p><a href="https://github.com/kohsuke/winsw/releases">WinSW</a>。这个软件是用于将单位电脑上的Frp客户端注册为服务。这样就不需要 cmd 去操作，非常方便。 Windows 电脑使用的版本是 ：WinSW.NET4.exe</p>
</li>
</ul>
<h2 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h2><p>下载 frp</p>
<pre><code class="bash">[root@chgocn ~]# wget https://github.com/fatedier/frp/releases/download/v0.40.0/frp_0.40.0_linux_amd64.tar.gz
</code></pre>
<p>解压 frp</p>
<pre><code class="bash">[root@chgocn ~]# tar -zxvf frp_0.40.0_linux_amd64.tar.gz
</code></pre>
<p>文件夹重命名</p>
<pre><code class="bash">[root@chgocn ~]# mv frp_0.40.0_linux_amd64 frp &amp;&amp; rm -rf 0.40.0_linux_amd64
</code></pre>
<p>修改配置信息</p>
<pre><code>[root@chgocn ~]# vi frps.ini
</code></pre>
<pre><code>[common]
bind_port = 7000
token=xxxxxxx

dashboard_port = 7500
dashboard_user = admin
dashboard_pwd = admin
</code></pre>
<p>保存后关闭服务器防火墙</p>
<pre><code>[root@chgocn ~]# systemctl stop firewalld.service
[root@chgocn ~]# firewall-cmd --state
not running
</code></pre>
<p>进入frp目录下并启动frp 服务端</p>
<pre><code>[root@chgocn ~]# cd frp &amp;&amp; ./frps -c frps.ini
</code></pre>
<p>访问服务器ip:7500，查看面板</p>
<h2 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h2><ol>
<li><p>下载frp，解压</p>
</li>
<li><p>修改frpc.ini文件，内容如下</p>
<pre><code>[common]
server_addr = *.*.*.*       #这里填云服务的公网IP地址
server_port = 7000
token = xxxxxx                 #与服务端token一致

[]
</code></pre>
</li>
<li><p>启动服务</p>
<pre><code>frpc.exe -c frpc.ini
</code></pre>
</li>
</ol>
<h3 id="配置Android客户端"><a href="#配置Android客户端" class="headerlink" title="配置Android客户端"></a>配置Android客户端</h3><p>使用 <a href="https://github.com/mainfunx/frpc_android">frpc-Android</a>，直接添加配置文件即可</p>
]]></content>
  </entry>
  <entry>
    <title>flutter GetX 框架</title>
    <url>/p/3ab42c8/</url>
    <content><![CDATA[<h2 id="Architecture-MVVM"><a href="#Architecture-MVVM" class="headerlink" title="Architecture MVVM"></a>Architecture MVVM</h2><ul>
<li>Views should never MAKE USE of a service directly.</li>
<li>Views should only contain logic if necessary. If the logic is from UI only items then we do the least amount of required logic and pass the rest to the ViewModel.</li>
<li>Views should ONLY render the state in its ViewModel.</li>
<li>ViewModels for widgets that represent page views are bound to a single View only.</li>
<li>ViewModels may be re-used if the UI requires the same functionality.</li>
<li>ViewModels should not know about other ViewModels.</li>
</ul>
<h2 id="CLean-Architecture"><a href="#CLean-Architecture" class="headerlink" title="CLean Architecture"></a>CLean Architecture</h2><p><img src="https://os-buket.oss-cn-hangzhou.aliyuncs.com/img/clean-architecture.jpg" alt="clean-architecture"></p>
<h2 id="Project-Structure"><a href="#Project-Structure" class="headerlink" title="Project Structure"></a>Project Structure</h2><pre><code class="yaml">- /bindings  
# Binding 类是使用依赖注入，解耦视图(view)和控制器(controller)的类，需要“绑定”到路由到状态管理器和依赖管理器。
# 命名规则：$page_binding.dart
- /config
# App的配置文件，主要是一些常量
- controllers
# 控制器，处理业务逻辑
# logic bussiness code must be here.
- /data
# 所有跟数据相关的类，包括数据模型、数据存储、网络服务等
# Directory responsible for containing everything related to our data
    - /helpers
    # 一些帮助工具
    - /models
    # 数据模型（实体类）
    # Our classes, or data models responsible for abstracting our objects.
    - /provider
    # 数据存储相关，可以是网络、本地数据库，
    # 这是我们存储服务的地方
        # 存储库只用来调解控制器和数据之间的通信。
        # 控制器不需要知道数据来自哪里，如果需要，可以在一个控制器上使用多个存储库。
        # 存储库必须由实体分隔，最好基于它们的数据库表。
        # 并且在它内部将包含所有从本地 api 或数据库请求数据的函数。
        # 也就是说，比如有一个用户表，增删改查这些接口都应该实现
        # 从一个 api，我们将有一个包含这个 api 对象的存储库，我们将在其中调用所有相应的
        # 对用户的功能。所以控制器不需要知道它来自哪里，存储库
        # This is where we store our Services
        # Here our repositories are just classes that will mediate the communication between our controller and our data.
        # Our controllers won&#39;t need to know where the data comes from, and you can use more than one repository on a controller if you need to.
        # The repositories must be separated by entities, and can almost always be based on their database tables.
        # And inside it will contain all its functions that will request data from a local api or database.
        # That is, if we have a user table that we will persist as, edit, add, update and delete, all these functions are requested 
        # from an api, we will have a repository with this object of the api where we will call all the respective 
        # functions to the user. So the controller does not need to know where it comes from, the repository being a 
        # mandatory attribute for the controllers in this model, you should always initialize the controller with at - /repository    
        - api_provider.dart
        - db_provider.dart
        - storage_provider.dart
        - repository.dart
    # Our data provider, can be an api, local database or firebase for example.
    - /services
        - dependency_injection.dart
        # 依赖注入，需要全局注入的类
        - service.dart

- /global_widgets 
# Widgets that can be reused by multiple **modules**.  

- /routes
# 路由
# In this repository we will deposit our routes and pages.  
# We chose to separate into two files, and two classes, one being routes.dart, containing its constant routes and the other for routing.  
    - routes.dart
    # class Routes &#123;
    # This file will contain your constants ex:  
    # class Routes &#123; const HOME = &#39;/ home&#39;; &#125;  
    - pages.dart
    # This file will contain your array routing ex :  
    # class AppPages &#123; static final pages = [  
    #  GetPage(name: Routes.HOME, page:()=&gt; HomePage()) 
    # ]&#125;;  
- /ui
    - /demo
    #存放一些demo的示例代码
    - /global_widgets
    #全局组件
    - /layouts
    #非全局用到的组件、布局
    - /pages
    #页面
    - /values
        - strings.dart
        - colors.dart
        - /languages
            - /from
                - pt-br.dart
                - en-au.dart
    - /theme
    #主题
    #Here we can create themes for our widgets, texts and colors
        - text_theme.dart  
        # inside ex: final textTitle = TextStyle(fontSize: 30)  
        - color_theme.dart  
        # inside ex: final colorCard = Color(0xffEDEDEE)  
        - app_theme.dart  
        # inside ex: final textTheme = TextTheme(headline1: TextStyle(color: colorCard))  
    - /utils
    #工具类
    #Here you can insert utilities for your application, such as masks, form keys or widgets
        - keys.dart  
        # inside ex: static final GlobalKey formKey = GlobalKey&lt;FormState&gt;();
        - masks.dart  
        # inside ex: static final maskCPF = MaskTextInputFormatter(mask: &quot;###.###.###-##&quot;, filter: &#123;&quot;#&quot;: RegExp(r&#39;[0-9]&#39;)&#125;);  
        - helpers.dart  
        - extension_x.dart  
    # Use classes to make your variables easier to use, eg Keys.myKey, Masks.maskCPF
</code></pre>
<h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h2><ul>
<li><a href="https://github.com/jonataslaw/getx">getx</a></li>
<li><a href="https://github.com/kauemurakami/getx_pattern">getx_pattern</a></li>
<li><a href="https://github.com/jonataslaw/get_cli">getx_cli</a> #need vpn,like v2rayN、clash</li>
<li><a href="https://github.com/OpenFlutter/flutter_screenutil">flutter_screenutil</a></li>
<li><a href="https://dart-lang.github.io/linter/lints/">Lints</a></li>
</ul>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
  </entry>
  <entry>
    <title>Git的常用命令</title>
    <url>/p/43832c2f/</url>
    <content><![CDATA[<h2 id="单词翻译"><a href="#单词翻译" class="headerlink" title="单词翻译"></a>单词翻译</h2><pre><code>Remote: 远程仓库
Repository: 仓库区（本地仓库）
Index / Stage：暂存区
Workspace：工作区
Origin: 远程主机 
Master：主干（用于发布realse版本）
Branch: 分支（用于处理一些耗时的工作，修复bug,开发新功能,可以有多个分支）
</code></pre>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><pre><code> # 在当前目录新建一个Git代码库
 $ git init
   
 # 新建一个目录，将其初始化为Git代码库
 $ git init [project-name]
   
 # 下载一个项目和它的整个代码历史
 $ git clone [project-url] 
 
 # 仅仅下载某个项目的分支
 $ git clone -b [branch-name] --single-branch [project-url]
</code></pre>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code># 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre>
<h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><pre><code># 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
</code></pre>
<h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><pre><code># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 合并指定分支到当前分支不使用fast forward并生成一个节点且不自动生成commit
$ git merge [branch] --no-ff no-commit

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code># 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
</code></pre>
<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><pre><code># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog    
</code></pre>
<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><pre><code># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all        
</code></pre>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop    
</code></pre>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code># 生成一个可供发布的压缩包
$ git archive
# 使更新的ignore文件生效
$ git rm -r --cached .
$ git add .
</code></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git 多账号配置</title>
    <url>/p/2375cf71/</url>
    <content><![CDATA[<h3 id="1-生成-git-账号公钥秘钥"><a href="#1-生成-git-账号公钥秘钥" class="headerlink" title="1. 生成 git 账号公钥秘钥"></a>1. 生成 git 账号公钥秘钥</h3><pre><code>ssh-keygen -t rsa -C username@xxx.com
</code></pre>
<h3 id="2-公钥拷贝及上传"><a href="#2-公钥拷贝及上传" class="headerlink" title="2. 公钥拷贝及上传"></a>2. 公钥拷贝及上传</h3><pre><code>cat ~/.ssh/id_rsa.pub
</code></pre>
<p>复制内容，然后在对应网站的个人账户-设置-ssh里进行添加。</p>
<h3 id="3-config-配置"><a href="#3-config-配置" class="headerlink" title="3. config 配置"></a>3. config 配置</h3><p>创建一个config文件，每个账号配置一个Host节点。</p>
<pre><code>vi ~/.ssh/config
</code></pre>
<p>主要配置文件内容如下</p>
<pre><code># github-1 account
Host u1.github.com
    HostName github.com
    User user1
    IdentityFile ~/.ssh/id_rsa_github1
    PreferredAuthentications publickey

# github-2 account
Host u2.github.com
    HostName github.com
    User user2
    IdentityFile ~/.ssh/id_rsa_github2
    PreferredAuthentications publickey


# gitlab account
Host gitlab.com
    HostName gitlab.com
    User iJarmin_lab
    IdentityFile ~/.ssh/id_rsa_gitlab
    PreferredAuthentications publickey

# oschina account
Host git.oschina.net 
    HostName git.oschina.net
    User username2
    IdentityFile ~/.ssh/id_rsa_oschina
    PreferredAuthentications publickey
</code></pre>
<p>配置项说明：</p>
<pre><code>    Host    　　##主机别名，这个可以随便写
    HostName　　##服务器真实地址
    IdentityFile　　##私钥文件路径
    PreferredAuthentications　　##认证方式
    User　　##用户名
</code></pre>
<h3 id="4-进行测试是否成功"><a href="#4-进行测试是否成功" class="headerlink" title="4. 进行测试是否成功"></a>4. 进行测试是否成功</h3><h4 id="4-1-测试github-账号1"><a href="#4-1-测试github-账号1" class="headerlink" title="4.1 测试github 账号1"></a>4.1 测试github 账号1</h4><pre><code>ssh -T git@u1.github.com
</code></pre>
<p>提示 you,re successfully authenticated,but Github does not provide shell access</p>
<h4 id="4-2-测试gitlab"><a href="#4-2-测试gitlab" class="headerlink" title="4.2 测试gitlab"></a>4.2 测试gitlab</h4><pre><code>ssh -T git@gitlab.com
</code></pre>
<p>提示welcome to gitlab</p>
<h3 id="5-配置账户的-username-和-email"><a href="#5-配置账户的-username-和-email" class="headerlink" title="5. 配置账户的 username 和 email"></a>5. 配置账户的 username 和 email</h3><p>请参考博客内文章</p>
<h3 id="6-通过-ssh-clone-项目"><a href="#6-通过-ssh-clone-项目" class="headerlink" title="6. 通过 ssh clone 项目"></a>6. 通过 ssh clone 项目</h3><p>比如，我们想用 github-2 account clone 仓库，原仓库地址为 <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;">&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;</a>:github-2/respository.git，我们需要将host 替换成host 别名（u2.github.com），如下</p>
<pre><code>git clone git@u2.github.com:github-2/respository.git
</code></pre>
<h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h3><ul>
<li><a href="https://www.cxyzjd.com/article/lovely_yoshino/114132477">Windows下Git多账号配置</a></li>
<li><a href="https://segmentfault.com/a/1190000022797854">GitHub 多账户设置</a></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 设置代理</title>
    <url>/p/49447f65/</url>
    <content><![CDATA[<h2 id="https访问"><a href="#https访问" class="headerlink" title="https访问"></a>https访问</h2><p>仅为github.com设置socks5代理(推荐这种方式, 公司内网就不用设代理了, 多此一举):</p>
<pre><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1086
</code></pre>
<p>其中1086是socks5的监听端口, 这个可以配置的, 每个人不同, 在macOS上一般为1086.<br>设置完成后, ~/.gitconfig文件中会增加以下条目:</p>
<pre><code>[http &quot;https://github.com&quot;]
    proxy = socks5://127.0.0.1:1086
</code></pre>
<h2 id="ssh访问"><a href="#ssh访问" class="headerlink" title="ssh访问"></a>ssh访问</h2><p>需要修改~/.ssh/config文件, 没有的话新建一个. 同样仅为github.com设置代理:</p>
<pre><code>Host github.com
    User git
    ProxyCommand nc -v -x 127.0.0.1:1086 %h %p
</code></pre>
<p>如果是在Windows下, 则需要个性%home%.ssh\config, 其中内容类似于:</p>
<pre><code>Host github.com
    User git
    ProxyCommand connect -S 127.0.0.1:1086 %h %p
</code></pre>
<p>这里-S表示使用socks5代理, 如果是http代理则为-H. connect工具git自带, 在\mingw64\bin\下面.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://gist.github.com/laispace/666dd7b27e9116faece6">git 设置和取消代理</a></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>对多个远程仓库地址自动设置不同的用户名称和邮箱</title>
    <url>/p/35988c4c/</url>
    <content><![CDATA[<h2 id="问题场景："><a href="#问题场景：" class="headerlink" title="问题场景："></a>问题场景：</h2><p>所有需要针对不同的仓库设置不同的用户名称或者用户邮件的场景。包括但不限于：</p>
<p>公司仓库要用一组用户名和邮箱，外网仓库要用一组用户名和邮箱<br>github 的仓库要用一组邮箱（github 用来保护用户隐私的邮箱）、gitlab 的仓库要用另一组邮箱<br>……<br>有人说，我可以在项目仓库下 git config user.email 针对单个仓库设置啊。是的，可以，但是当你有大量的仓库需要管理的时候，你就会感到痛苦了。我们要达到的目标是做一次性的设置，以后新建仓库都会自动适用对应的信息，不只限于 “user.name” 和 “user.email”.</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>前提条件：git客户端版本大于 2.13</p>
<p>首先，假设：</p>
<p>你已经全局配置了公司邮箱和名称<br>user.name = xxxxx,<br>user.email = <a href="mailto:&#x78;&#120;&#x78;&#120;&#x78;&#x40;&#x63;&#x6f;&#109;&#112;&#97;&#x6e;&#121;&#x2e;&#99;&#111;&#x6d;">&#x78;&#120;&#x78;&#120;&#x78;&#x40;&#x63;&#x6f;&#109;&#112;&#97;&#x6e;&#121;&#x2e;&#99;&#111;&#x6d;</a><br>你在 E:\codes 下存放所有的 git repos。<br>现在你要为 gitlab 和 github 分别设置不同的用户邮箱：<br>Gitlab: “<a href="mailto:&#x31;&#50;&#51;&#x36;&#x35;&#x2d;&#x75;&#115;&#x65;&#114;&#x40;&#117;&#x73;&#x65;&#114;&#115;&#46;&#x6e;&#111;&#114;&#x65;&#x70;&#x6c;&#121;&#x2e;&#x67;&#105;&#116;&#108;&#97;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#x31;&#50;&#51;&#x36;&#x35;&#x2d;&#x75;&#115;&#x65;&#114;&#x40;&#117;&#x73;&#x65;&#114;&#115;&#46;&#x6e;&#111;&#114;&#x65;&#x70;&#x6c;&#121;&#x2e;&#x67;&#105;&#116;&#108;&#97;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>“<br>Github: “<a href="mailto:&#50;&#x33;&#x34;&#x32;&#x34;&#x2b;&#x75;&#x73;&#x65;&#114;&#x40;&#x75;&#115;&#101;&#x72;&#x73;&#x2e;&#x6e;&#111;&#x72;&#101;&#x70;&#108;&#121;&#x2e;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;">&#50;&#x33;&#x34;&#x32;&#x34;&#x2b;&#x75;&#x73;&#x65;&#114;&#x40;&#x75;&#115;&#101;&#x72;&#x73;&#x2e;&#x6e;&#111;&#x72;&#101;&#x70;&#108;&#121;&#x2e;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>“<br>现在建立两个特殊的目录：</p>
<p>E:\codes<br>├── gitlab // 专门用于存放托管在 gitlab 的代码仓库<br>├── github // 专门用户存放托管在 github 的代码仓库<br>打开git的全局配置文件（一般是在 C:\Users{用户名}.gitconfig, Mac 下是在 /Users/{用户名}/.gitconfig），增加两段配置，如下（第 5 行起的部分）：</p>
<pre><code>  [user]
      name = xxxxx
      email = xxxxx@company.com

+ [includeIf &quot;gitdir:codes/github/&quot;]
+    path = ./.github
+
+ [includeIf &quot;gitdir:codes/gitlab/&quot;]
+    path = ./.gitlab
</code></pre>
<p>在全局 .gitconfig 文件夹相同的位置，创建 .github 和 .gitlab 文件，内容如下：</p>
<pre><code># .github
[user]
    email = 23424+user@users.noreply.github.com
</code></pre>
<pre><code># .gitlab
[user]
    email = 12365-user@users.noreply.gitlab.com
</code></pre>
<p>这样配置以后，如果你是在 E:\codes\gitlab 下的某个项目时，你的 email 是 <a href="mailto:&#x31;&#x32;&#x33;&#54;&#x35;&#x2d;&#x75;&#115;&#101;&#x72;&#64;&#117;&#115;&#x65;&#x72;&#115;&#x2e;&#x6e;&#111;&#114;&#x65;&#x70;&#x6c;&#121;&#x2e;&#x67;&#105;&#x74;&#x6c;&#97;&#x62;&#46;&#99;&#111;&#109;">&#x31;&#x32;&#x33;&#54;&#x35;&#x2d;&#x75;&#115;&#101;&#x72;&#64;&#117;&#115;&#x65;&#x72;&#115;&#x2e;&#x6e;&#111;&#114;&#x65;&#x70;&#x6c;&#121;&#x2e;&#x67;&#105;&#x74;&#x6c;&#97;&#x62;&#46;&#99;&#111;&#109;</a>，如果你是在 E:\codes\github 下的某个项目时，你的 email 是 <a href="mailto:&#x32;&#51;&#52;&#x32;&#x34;&#43;&#117;&#x73;&#101;&#114;&#x40;&#x75;&#115;&#101;&#x72;&#115;&#x2e;&#110;&#111;&#x72;&#101;&#x70;&#108;&#121;&#46;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#x32;&#51;&#52;&#x32;&#x34;&#43;&#117;&#x73;&#101;&#114;&#x40;&#x75;&#115;&#101;&#x72;&#115;&#x2e;&#110;&#111;&#x72;&#101;&#x70;&#108;&#121;&#46;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>，其它情况下，是 <a href="mailto:&#x78;&#x78;&#x78;&#120;&#120;&#x40;&#99;&#x6f;&#x6d;&#x70;&#x61;&#x6e;&#121;&#46;&#x63;&#x6f;&#x6d;">&#x78;&#x78;&#x78;&#120;&#120;&#x40;&#99;&#x6f;&#x6d;&#x70;&#x61;&#x6e;&#121;&#46;&#x63;&#x6f;&#x6d;</a>.</p>
<p>当然除了 user.email 之外，你也可以针对性地指定其它配置项，包括但不限于 commit.gpgsign、user.signingkey.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>以上方法使用到的其实是 git 本身的 “Conditional Includes” 功能，根据不同的情况包含不同的配置文件。这里用到的是基于路径的条件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ofcss.com/2020/02/17/auto-config-user-name-email-for-different-remote-repository.html">多个远程仓库, 如何自动设置不同邮箱或用户名</a></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git 使用</title>
    <url>/p/86c88f6a/</url>
    <content><![CDATA[<h2 id="下载-git-bash"><a href="#下载-git-bash" class="headerlink" title="下载 git bash"></a>下载 git bash</h2><p><a href="https://gitforwindows.org/">gitforwindows</a></p>
<h2 id="根据选择进行安装"><a href="#根据选择进行安装" class="headerlink" title="根据选择进行安装"></a>根据选择进行安装</h2><h2 id="配置全局-git-用户"><a href="#配置全局-git-用户" class="headerlink" title="配置全局 git 用户"></a>配置全局 git 用户</h2><h2 id="配置-ssh-key"><a href="#配置-ssh-key" class="headerlink" title="配置 ssh key"></a>配置 ssh key</h2><pre><code class="bash">ssh-keygen -t rsa -b 4096 -C &quot;chgocn@gmail.com&quot;
cat ~/.ssh/id_rsa.pub
</code></pre>
<pre><code class="bash">Lenovo@DESKTOP-91MGDB0 MINGW64 /c/project
$ ssh-keygen -t rsa -b 4096 -C &quot;chgocn@gmail.com&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/Lenovo/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /c/Users/Lenovo/.ssh/id_rsa
Your public key has been saved in /c/Users/Lenovo/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:UOAA1E2ZjkPA9WrkddzdmhH+mmZRaDn3pSbGj2fg9ew chgocn@gmail.com
The key&#39;s randomart image is:
+---[RSA 4096]----+
| o+=ooo+.   .    |
|  . o++o . o =   |
|   ..o= o . O + .|
|   ooo.o   o O o.|
|    +.  S   O = .|
|   .       o @ o |
|            B + o|
|           o o . |
|                E|
+----[SHA256]-----+

Lenovo@DESKTOP-91MGDB0 MINGW64 /c/project
$ cat ~/.ssh/id_rsa
id_rsa      id_rsa.pub

Lenovo@DESKTOP-91MGDB0 MINGW64 /c/project
$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDXdHraHrsJpZJrs3cCXag8Bdbj6U+oW6XyxwVcGowTLOSpppSyDu/nwiZeCBmzW3EQsDtQ2GAxQt3ZJtrl3ucIINACfEnH+2xJ/ymoI1NF4Y35AqhK6gEgDkUEzJwI/NeEwvyYtTfu9cnGPXQjeII+KJZ3s+Q6TJx2hSnpH6bL6gNxyyiyzkFjPLqArki2SAaNwHXE3fwgEebllqzStiY5+rtgdP6Wzs+lPYnSH6heKGAIt87J2bETQcPRpqpWmHYiKAPjj2Hs/fW99YEUAWNP0OIFwkJrstkn6/FamAAIaigL6c4xXlanz0cGo9mG0hEDB7EkzWy5z6ZLLPMegNZIoxvcU1gnaH+2ymhWz1UZLzq8tY1q32QAEDC2MgeQYjys/SrdTh+Nk7pVaPJ/Cg2AmWmLlDeCpXwK/zJqTJANG/oBQCfKrQpCW+3AxBRBZLSoPCKfHbot2kmiXWEyW+cejMewg2W/R8h05P7qT1v2N4dx+en8b5q...
</code></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 docker 安装 gitea</title>
    <url>/p/ca4ad0e5/</url>
    <content><![CDATA[<p>在当前目录下</p>
<pre><code>mkdir gitea
</code></pre>
<pre><code>docker run -d \
  --privileged=true \
  --restart=always \
  --name=gitea \
  -p 9310:22 \
  -p 9311:3000 \
  -v $PWD/gitea:/data \
  gitea/gitea:latest
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Git 工作流</title>
    <url>/p/fea0ccee/</url>
    <content><![CDATA[<h2 id="Git-Workflow"><a href="#Git-Workflow" class="headerlink" title="Git Workflow"></a>Git Workflow</h2><p><img src="https://os-buket.oss-cn-hangzhou.aliyuncs.com/img/git-flow.png" alt="git-flow"></p>
<h3 id="流程演示"><a href="#流程演示" class="headerlink" title="流程演示"></a>流程演示</h3><p>1.切到 develop 分支，更新 develop 最新代码</p>
<pre><code>git checkout develop
git pull --rebase
</code></pre>
<p>2.新建 feature 分支，开发新功能</p>
<pre><code>git checkout -b feature/xxx
...
git add &lt;files&gt;
git commit -m &quot;feat(xxx): commit a&quot;
git commit -m &quot;feat(xxx): commit b&quot;
# 其他提交
...
</code></pre>
<p>如果此时 develop 分支有一笔提交，影响到你的 feature 开发，可以 rebase develop 分支，前提是 该 feature 分支只有你自己一个在开发，如果多人都在该分支，需要进行协调：</p>
<pre><code># 切换到 develop 分支并更新 develop 分支代码
git checkout develop
git pull --rebase

# 切回 feature 分支
git checkout feature/xxx
git rebase develop

# 如果需要提交到远端，且之前已经提交到远端，此时需要强推(强推需慎重！)
git push --force
上述场景也可以通过 git cherry-pick 来实现，有兴趣的可以去了解一下这个指令。
</code></pre>
<p>3.完成 feature 分支，合并到 develop 分支</p>
<pre><code># 切到 develop 分支，更新下代码
git check develop
git pull --rebase

# 合并 feature 分支
git merge feature/xxx --no-ff

# 删除 feature 分支
git branch -d feature/xxx

# 推到远端
git push origin develop
</code></pre>
<p>4.当某个版本所有的 feature 分支均合并到 develop 分支，就可以切出 release 分支，准备发布新版本，提交测试并进行 bug fix</p>
<pre><code># 当前在 develop 分支
git checkout -b release/xxx

# 在 release/xxx 分支进行 bug fix
git commit -m &quot;fix(xxx): xxxxx&quot;
...
</code></pre>
<p>5.所有 bug 修复完成，准备发布新版本</p>
<pre><code># master 分支合并 release 分支并添加 tag
git checkout master
git merge --no-ff release/xxx --no-ff
# 添加版本标记，这里可以使用版本发布日期或者具体的版本号
git tag 1.0.0

# develop 分支合并 release 分支
git checkout develop
git merge --no-ff release/xxx

# 删除 release 分支
git branch -d release/xxx
至此，一个新版本发布完成。
</code></pre>
<p>6.在release未发布前，又中途添加需求</p>
<pre><code># master 分支合并 release 分支并添加 tag
git checkout master
git merge --no-ff release/xxx --no-ff
# 添加版本标记，这里可以使用版本发布日期或者具体的版本号
git tag 1.0.0

# develop 分支合并 release 分支
git checkout develop
git merge --no-ff release/xxx

# 删除 release 分支
git branch -d release/xxx
</code></pre>
<p>7.至此，一个新版本发布完成。</p>
<p>8.线上出现 bug，需要紧急发布修复版本</p>
<pre><code># 当前在 master 分支
git checkout master

# 切出 hotfix 分支
git checkout -b hotfix/xxx

... 进行 bug fix 提交

# master 分支合并 hotfix 分支并添加 tag(紧急版本)
git checkout master
git merge --no-ff hotfix/xxx --no-ff
# 添加版本标记，这里可以使用版本发布日期或者具体的版本号
git tag 1.0.1

# develop 分支合并 hotfix 分支(如果此时存在 release 分支的话，应当合并到 release 分支)
git checkout develop
git merge --no-ff hotfix/xxx

# 删除 hotfix 分支
git branch -d hotfix/xxx
</code></pre>
<p>至此，紧急版本发布完成。</p>
<h3 id="提交信息规范"><a href="#提交信息规范" class="headerlink" title="提交信息规范"></a>提交信息规范</h3><p>提交信息规范部分参考 Angular.js commit messgae。<br>git commit 格式 如下：</p>
<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
</code></pre>
<p>各个部分的说明如下：</p>
<ul>
<li><p>type 类型，提交的类别</p>
<ul>
<li>feat: 新功能</li>
<li>fix: 修复 bug</li>
<li>docs: 文档变动</li>
<li>style: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等</li>
<li>refactor: bug 修复和添加新功能之外的代码改动</li>
<li>perf: 提升性能的改动</li>
<li>test: 添加或修正测试代码</li>
<li>chore: 构建过程或辅助工具和库（如文档生成）的更改</li>
</ul>
</li>
<li><p>scope 修改范围<br>  主要是这次修改涉及到的部分，简单概括，例如 login、train-order</p>
</li>
<li><p>subject 修改的描述<br>  具体的修改描述信息</p>
</li>
<li><p>范例</p>
<p>  feat(detail): 详情页修改样式<br>  fix(login): 登录页面错误处理<br>  test(list): 列表页添加测试代码</p>
</li>
</ul>
<p>这里对提交规范加几点说明：</p>
<ol>
<li>type + scope 能够控制每笔提交改动的文件尽可能少且集中，避免一次很多文件改动或者多个改动合成一笔。</li>
<li>subject 对于大部分国内项目而已，如果团队整体英文不是较高水平，比较推荐使用中文，方便阅读和检索。</li>
<li>避免重复的提交信息，如果发现上一笔提交没改完整，可以使用 git commit –amend 指令追加改动，尽量避免重复的提交信息。</li>
</ol>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
  </entry>
  <entry>
    <title>github 设置代理</title>
    <url>/p/473cf362/</url>
    <content><![CDATA[<h2 id="分辨需要设置的代理"><a href="#分辨需要设置的代理" class="headerlink" title="分辨需要设置的代理"></a>分辨需要设置的代理</h2><ul>
<li>HTTP 形式：git clone <a href="https://github.com/PBK-B/test.git">https://github.com/PBK-B/test.git</a></li>
<li>SSH 形式：git clone <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;</a>:PBK-B/test.git</li>
</ul>
<h2 id="HTTP-形式"><a href="#HTTP-形式" class="headerlink" title="HTTP 形式"></a>HTTP 形式</h2><p>走 HTTP 代理</p>
<pre><code class="bash">git config --global http.proxy &quot;http://127.0.0.1:8080&quot;

git config --global https.proxy &quot;http://127.0.0.1:8080&quot;
</code></pre>
<p>走 socks5 代理（如 小飞机 or V2xxxx）</p>
<pre><code class="bash">git config --global http.proxy &quot;socks5://127.0.0.1:1080&quot;

git config --global https.proxy &quot;socks5://127.0.0.1:1080&quot;
</code></pre>
<p>取消设置</p>
<pre><code class="bash">git config --global --unset http.proxy

git config --global --unset https.proxy
</code></pre>
<h2 id="SSH-形式"><a href="#SSH-形式" class="headerlink" title="SSH 形式"></a>SSH 形式</h2><p>修改 ~/.ssh/config 文件（不存在则新建）：</p>
<pre><code class="config文件内容"># 必须是 github.com
Host github.com
   HostName github.com
   User git
   # 走 HTTP 代理
   # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=8080
   # 走 socks5 代理（如小飞机 or V2xxx）
   # ProxyCommand nc -v -x 127.0.0.1:1080 %h %p
</code></pre>
<p>对于 Windows 用户，要使用 socks5 代理却没有 nc 的，可以将</p>
<p>ProxyCommand nc -v -x 127.0.0.1:1080 %h %p<br>换成<br>ProxyCommand connect -S 127.0.0.1:1080 %h %p</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://bin.zmide.com/?p=748">GIT Proxy 一键设置代理让你的 git clone Github 再也不像百度云一样内行</a></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/p/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>test</p>
<pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hexo基本使用</title>
    <url>/p/c3c198d3/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm install hexo -g #安装  
npm update hexo -g #升级  
hexo init #初始化
</code></pre>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><pre><code>hexo n &quot;my blog&quot; == hexo new &quot;my blog&quot; #新建文章
hexo p == hexo publish
hexo g == hexo generate#生成静态网页
hexo s == hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）
hexo d == hexo deploy#将.deploy目录部署到GitHub
hexo clean #清除缓存 网页正常情况下可以忽略此条命令
hexo generate --deploy
hexo deploy --generate
hexo deploy -g
hexo server -g
</code></pre>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><pre><code>hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。
hexo server -s #静态模式
hexo server -p 5000 #更改端口
hexo server -i 192.168.1.1 #自定义 IP
</code></pre>
<h2 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h2><pre><code>hexo generate --watch #监视文件变动
</code></pre>
<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><pre><code>hexo publish [layout] &lt;title&gt;
</code></pre>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>hqt 项目总结</title>
    <url>/p/8ce4cdf8/</url>
    <content><![CDATA[<p>项目结束之后的一些总结与沉淀。</p>
<ul>
<li>flutter</li>
<li>getx</li>
</ul>
<h3 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h3><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>ApiController:基类接口控制器，将网络接口绑定到GetXController的生命周期上，接口所需要用到的参数会全部放入allParams 字典中。泛型为T。</li>
<li> PageController: 分页接口控制器，封装分页业务。泛型为List<T>。</li>
<li>ListController:有限列表接口控制器，泛型为List<T>。</li>
<li>MtController:针对接口返回类型T进行再次转换成为M的控制器。</li>
<li>ResponseMixin: 封装接口统一解析，错误处理。</li>
</ul>
<p><img src="https://os-buket.oss-cn-hangzhou.aliyuncs.com/img/getx.png" alt="getx"></p>
<h4 id="ViewModel关系图"><a href="#ViewModel关系图" class="headerlink" title="ViewModel关系图"></a>ViewModel关系图</h4><ul>
<li>页面的命名以<strong>Page</strong>结尾，视图的命名以<strong>View</strong>结尾，网络接口控制器的命名以<strong>Controller</strong>结尾，布局的命名以<strong>Layout</strong>结尾。</li>
<li>网络接口类型命名：分页命名<strong>pagi</strong>，有限列表命名<strong>list</strong>，操作类命名<strong>curd</strong></li>
<li>网络接口控制器（<strong>Controller</strong>）与视图（<strong>View</strong>）是一对一的关系。如果视图是多个样式，可以在视图内定义【type】类型区分。比如登陆：LoginController &lt;—&gt; LoginView</li>
<li>页面（<strong>Page</strong>）与视图（<strong>View</strong>）是一对一或一对多的关系。例如：HomePage里有3个View，HomeView、ExpolreVIew、UserView。</li>
<li>视图（<strong>View</strong>）可以看成是普通的Widget，所以视图中可以包含其它视图（<strong>View</strong>）</li>
</ul>
<p>下面为登录页面的图解。</p>
<p><img src="https://os-buket.oss-cn-hangzhou.aliyuncs.com/img/api_draw_io.drawio.png" alt="api_draw_io.drawio"></p>
<h3 id="模板化代码"><a href="#模板化代码" class="headerlink" title="模板化代码"></a>模板化代码</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li>开发文档，这里是excel格式，用来输出app功能，保证视图跟网络请求一对一关系。比如登陆：user/login</li>
<li>网络请求文档 json 格式，后端网络使用的 swagger，所以这里很轻松拿到接口数据</li>
<li>各种解析脚本，这里是excel2json.py、swagger2dart.py、其它模板性文件生成脚本等</li>
<li>openapigenerator: 根据 swagger 配置文件生成dart客户端代码</li>
<li>vscode 插件，根据框架层，编写插件，快捷生成模板代码</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li>规范后端接口返回</li>
<li>规范UI设计</li>
</ul>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>业务分层，更便于维护、测试</li>
<li>自动化生成重复性代码，只需要把精力关注在具体业务上</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>设计把接口数据分层展示时，传递数据不便</li>
<li>相同功能，相同界面，后台多个接口，无法满足需求</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>暂时打破Controller与View是一对一的关系，改成多对多的关系，或Page绑定最先显示View的Controller，实现Page层的数据更新</li>
<li>通过泛型的方式将Controller绑定到View上，不传泛型，则绑定同名Controller</li>
<li>将View的render方法暴露给其它组件，不调用render方法，则使用内置View</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>jadx 错误总结</title>
    <url>/p/63b3c1c/</url>
    <content><![CDATA[<h3 id="jadx-1-3-4错误收集"><a href="#jadx-1-3-4错误收集" class="headerlink" title="jadx 1.3.4错误收集"></a>jadx 1.3.4错误收集</h3><ul>
<li><strong><code>jadx.plugins.input.dex.DexException: Bad checksum</code></strong></li>
</ul>
<pre><code>jadx-gui.bat -Pdex-input.verify-checksum=no
</code></pre>
<p>或编辑**<code>jadx-gui.bat</code>**文件,在第74行后面添加 <code> -Pdex-input.verify-checksum=no</code></p>
]]></content>
  </entry>
  <entry>
    <title>js 运行时</title>
    <url>/p/516f64dc/</url>
    <content><![CDATA[<h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a><a href="https://nodejs.org/en/">nodejs</a></h3><p>js 运行时，依赖管理。</p>
<h3 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a><a href="https://github.com/nvm-sh/nvm">nvm</a></h3><p><code>nvm</code>允许您通过命令行快速安装和使用不同版本的node</p>
<h3 id="nvm-windows"><a href="#nvm-windows" class="headerlink" title="nvm-windows"></a><a href="https://github.com/coreybutler/nvm-windows">nvm-windows</a></h3><p>window 版 nvm。非官方。</p>
<h3 id="bun"><a href="#bun" class="headerlink" title="bun"></a><a href="https://github.com/oven-sh/bun">bun</a></h3><p>Bun 是像 Node 或 Deno 一样的现代 JavaScript 运行时。主打快速。</p>
]]></content>
  </entry>
  <entry>
    <title>某 js 插件编写文档</title>
    <url>/p/f28018d1/</url>
    <content><![CDATA[<pre><code>// [rule: ^demo(.*)$] 使用正则匹配,括号中为期望匹配的值
// [rule: demo ?] 使用问号匹配
// [rule: demo] 直接匹配
// [cron: 36 11,17 * * *] 定时任务
// [admin: true] 是否只允许管理员使用
// [disable: false] 是否禁用
// [priority: 10] 匹配优先级
// [server: 1 ] 如果不指定rule和cron时,设置为非空则指定为一个空服务,否则这个js不会加载
&#123;//内置函数
   //存储相关 存储结构为 &#123;mainKey1:&#123;key1:value,key2:value&#125;,mainKey2:&#123;key1:value,key2:value&#125;&#125;&#125;
    bucketKeys(mainKey)//获取所有key名称
    bucketGet(mainKey,key)//取值
    bucketSet(mainKey,key,value)//存值
    push(&#123;
        imType:string,//发送到指定渠道,如qq,wx,必须
        userID:&quot;&quot;,//groupCode不为0时为@指定用户,可选
        groupCode:&quot;&quot;,//可选
        content:string,//发送消息
    &#125;)//给指定im发送消息
    session(&#123;
        imTpye:&quot;&quot;,//模拟指定渠道,如qq,wx,非必须,默认类型carry
        msg:&quot;&quot;,//发送的消息,必须
        chatId: 0,//模拟的群号,必须是数字
        userId:&quot;&quot;//模拟的用户id
    &#125;)//模拟一条im消息,可以多次发送,使用Session(&quot;msg&quot;)为使用默认配置
    //返回值为一个函数,可多次调用,每次返回交互结果,具体结构为&#123;hasNext:true,message:&quot;msg&quot;&#125;
&#125;
Sender//Sender对象
&#123;
    Sender:&#123;//真实的Sender对象,可以做更多事,但更复杂,一般情况请勿使用
        GetUserID()// 发送人用户id
        GetChatID()// 群号
        GetImType()// 聊天来源类型如:qq,wx等,其中fake为特殊调用可能为cron调用
        GetMessageID()// 获取消息id
        RecallMessage(id)// 撤回消息
        GetUsername()// 发送人名称
        GetChatname()// 群名,不一定精确
        IsReply()// 是否为回复消息
        GetReplySenderUserID()// 获取回复的消息id
        GetRawMessage()//获得原始的消息,根据ImType不一样,消息也不一样
        SetMatch([]string)//设置Match,映像参数获取
        SetAllMatch([][]string)//设置Match,影响参数获取
        GetMatch()//获取Match,获取参数匹配的规则
        GetAllMatch()//获取所有Match,结构双层数组
        Get(...int)//获取Match,获取指定位置参数,返回string
        GetContent()//获取消息
        SetContent(string)//设置消息
        IsAdmin()// 是否管理
        IsMedia()// 是否媒体资源
        Reply(&quot;&quot;)// 回复消息
        Delete()//删除(撤回)当前消息
        Disappear(lifetime ...time.Duration)//设置消息有效时长,到时间自动撤回,部分ImType有效
        Finish()//结束时调用,不要调用,否则可能出奇奇怪怪的bug
        Continue()//继续,允许该消息被后续插件继续处理
        IsContinue()//是否继续
        ClearContinue()//清理是否继续,禁止后续插件继续处理
        Await(Sender, func(Sender) interface&#123;&#125;, ...interface&#123;&#125;)//等待一条消息,js中不要使用,容易出各种bug
        Copy()//复制
        GroupBan(uid, time)//群禁言,需要在群聊才可用
        GroupKick(uid, reject)//群踢人,reject为是否拉黑名单,需要在群聊才可用
        AtLast()//设置回复的消息暂时先存储,等会一起发送
        UAtLast()//取消消息的暂时存储,改为立即发送
        IsAtLast()//是否暂存消息
        MessagesToSend()// 获取将要发送的消息
    &#125;
    Continue()//同Sender
    GetUserID() //同Sender
    SetContent(s string)  //同Sender
    GetContent() string  //同Sender
    GetImType() string //同Sender 
    RecallMessage(p ...interface&#123;&#125;) //同Sender
    GetUsername() string //同Sender
    GetMessageID() string  //同Sender
    GetGroupCode() int  //同Sender
    IsAdmin() bool  //同Sender
    Reply(text string) []string //同Sender
    Await(timeout, fromGroup, callback)//等待一条消息,fromGroup:布尔值,是否允许从当前群接受所有人消息,callback属于冗余设计,不需要填写,当不存在就行
&#125;
//上下文获取
param(n)//获取rule中期望捕获的第n个字符串,中文需要使用 encodeURI(param(n))
ImType()//聊天来源类型如:qq,wx等,其中fake为特殊调用可能为cron调用
GetImType()//同ImType()
GetUserID()//发送人用户id
GetUsername()//发送人昵称
GetMessageID()//获取消息id
GetChatID()//群号
GetChatname()//群名
GetContent()//获取接受到的消息
isAdmin()//发送人是否管理员
//系统功能相关
importJs(js)//引用一个js文件,路径相对replies目录,如:importJs(&#39;test/test.js&#39;) importJs(&#39;./test&#39;)
importDir(dir)//引用一个目录的js文件,路径相对replies目录,如:importDir(&#39;test/test1&#39;) importDir(&#39;./test/&#39;)
cancall(name)//返回特殊调用的函数
call(name,value)//特殊调用
Debug(log)//打印日志
sleep(millisecond)//休眠
GroupBan(uid, time)//群禁言,需要在群聊才可用
GroupKick(uid, reject)//群踢人,reject为是否拉黑名单,需要在群聊才可用
timeFmt(&quot;2020-01-01 00:00:00&quot;)//按指定格式获取当前时间字符串
request(&#123;
    url:&quot;&quot;,//必须
    method:&quot;&quot;,//get,post,put,delete,可选,默认get
    headers:&#123;&#125;,//可选
    body:&quot;&quot;,//可选
    dataType:&quot;&quot;,//location=&gt;重定向url,json=&gt;尝试解析为对象,否则为body字符串,可选
    useproxy:false,//可选
    timeOut:millisecond,//可选,请求超时
&#125;
//,function(error,info,body)&#123;&#125; 可选参数请求回调,回调参数分别为:错误信息,请求信息,请求结果,获取http状态码使用info结构为&#123;status,body,header&#125;
)//发送请求
require(&quot;request&quot;)//固定写法,获取request函数
Logger()//获取log对象,用法Logger().log(xxx)  Logger().error(xxx)
console.log(&quot;string&quot;)//简单适配的日志工具,也支持console.info(xxx) console.error(xxx)
nil//go语言中的null
//存储相关 存储结构为 &#123;mainKey1:&#123;key1:value,key2:value&#125;,mainKey2:&#123;key1:value,key2:value&#125;&#125;&#125;
bucketGet(mainKey,key)//同名函数
bucketSet(mainKey,key,value)//同名函数
bucketKeys(mainKey)//同名函数
get(key)//同bucketGet(&quot;otto&quot;,key)
set(key,value)//同bucketSet(&quot;otto&quot;,key,value)
//消息相关
input(time /*[,str]*/)//等待下一个消息,str不为空时可接受其他群的消息
breakIn(str)//生成一个新的消息向下传递,可以被所有命令处理(包括当前js,所以需要防止递归)
Continue()//消息继续向下传递，可以被其他命令处理
Delete()//删除接受到的这条消息
RecallMessage(id)//撤回指定消息,同GetMessageID一起使用
image(string)//图片地址转可拼接消息字符串
push()//同名函数
notifyMasters(string)//通知管理员
sendText(string)//发送文本
sendImage(url)//发送图片
sendVideo(url)//发送视频
</code></pre>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
  </entry>
  <entry>
    <title>markdown-to-ppt</title>
    <url>/p/315ed93b/</url>
    <content><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>使用<a href="https://github.com/webpro/reveal-md">reveal-md</a>进行渲染，适合组内分享</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code class="bash">reveal-md slides.md -w --highlight-theme github --css style.css
</code></pre>
<h3 id="导出-pdf"><a href="#导出-pdf" class="headerlink" title="导出 pdf"></a>导出 pdf</h3><pre><code>reveal-md slides.md --print slides.pdf
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>模拟弱网络测试</title>
    <url>/p/db20c36/</url>
    <content><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>charles：抓包代理工具</li>
<li>Android 机器</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>charles 通过 Proxy-&gt;Throttle Settings，并设置好代理 Proxy(默认代理端口：8888)，图后补。</p>
<p>Android 手机和 PC 保持同一局域网，并设置 wifi 代理。adb 代码如下：</p>
<pre><code>adb shell settings put global http_proxy pc-ip:8888
</code></pre>
<p>移除代理</p>
<pre><code>adb shell settings delete global http_proxy

adb shell settings delete global global_http_proxy_host

adb shell settings delete global global_http_proxy_port
</code></pre>
<p><strong>注意：移除代理后要重启手机才能生效。设置代理可以多次设置，立即生效。</strong></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://testerhome.com/topics/7384">https://testerhome.com/topics/7384</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mustache 文档笔记</title>
    <url>/p/be6a9fa0/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Mustache是一个logic-less（轻逻辑）模板解析引擎，</p>
<p>它是为了使用户界面与业务数据（内容）分离而产生的。</p>
<p>官方文档地址：</p>
<p>主页：<a href="https://github.com/janl/mustache.js/">https://github.com/janl/mustache.js/</a><br>文档：<a href="https://mustache.github.io/mustache.5.html">https://mustache.github.io/mustache.5.html</a></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>1. &#123;&#123;keyName&#125;&#125;
2. &#123;&#123;&#123;keyName&#125;&#125;&#125;
3. &#123;&#123;#keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;
4. &#123;&#123;^keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;
5. &#123;&#123;.&#125;&#125;
6. &#123;&#123;!comments&#125;&#125;
7. &#123;&#123;>partials&#125;&#125;
</code></pre>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><pre><code>1. &#123;&#123;keyName&#125;&#125;简单的变量替换。

2. &#123;&#123;&#123;keyName&#125;&#125;&#125; 带有HTML变量。

3. &#123;&#123;#keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;以#开始、以/结束表示区块，它会根据当前上下文中的键值来对区块进行一次或多次渲染。它的功能很强大，有类似if、foreach的功能。

4. &#123;&#123;^keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;该语法与&#123;&#123;#keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;类似，不同在于它是当keyName值为null, undefined, false时才渲染输出该区块内容。

5. &#123;&#123;.&#125;&#125; &#123;&#123;.&#125;&#125;表示枚举，可以循环输出整个数组

6. &#123;&#123;! &#125;&#125;表示注释

7. &#123;&#123;>partials&#125;&#125;以&gt;开始表示子模块，当结构比较复杂时，我们可以使用该语法将复杂的结构拆分成几个小的子模块。
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>n1 电视系统转刷 openwrt，并设置旁路由</title>
    <url>/p/eb22c0af/</url>
    <content><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>原N1系统：YYF电视系统</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>U盘</p>
</li>
<li><p>N1盒子</p>
</li>
<li><p>Windows PC</p>
</li>
<li><p><strong>openwrt</strong> 镜像文件</p>
</li>
<li><p>balenaEtcher软件：用于将镜像 openwrt 镜像文件刷入U盘中</p>
</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>将U盘插入PC，并打开balenaEtcher软件，选择openwrt镜像文件，点击 flash，等待刷入成功标识”flash completed”。</p>
</li>
<li><p>保持N1和PC在同一局域网下。N1通电，进入N1系统，查看IP，通过命令连接N1，假释N1 IP地址是192.168.68.253</p>
<pre><code class="bash">adb connect 192.168.68.253:5555
</code></pre>
</li>
<li><p>拔下U 盘，将U盘插入N1盒子远离HDMI接口的USB接口中，然后在PC中执行以下命令让N1通过U盘载入</p>
<pre><code class="bash">adb shell reboot update
</code></pre>
</li>
<li><p>静等N1启动成功，查看是否广播出无线网，名称： Phicomm-n1</p>
</li>
<li><p>PC连接Phicomm-n1，密码：password，查看网关地址，比如网关地址为192.168.1.253</p>
</li>
<li><p>通过浏览器访问192.168.1.253，登陆 openwrt 后台，密码password</p>
</li>
<li><p>找到菜单 TTYD，进入控制台</p>
<pre><code>root
password
cd /root
./install_emmc.sh
</code></pre>
</li>
<li><p>拔掉U盘，重启N1</p>
</li>
</ol>
<h3 id="设置旁路由"><a href="#设置旁路由" class="headerlink" title="设置旁路由"></a>设置旁路由</h3><h4 id="N1作为旁路由-自定义网关，推荐"><a href="#N1作为旁路由-自定义网关，推荐" class="headerlink" title="N1作为旁路由(自定义网关，推荐)"></a><strong>N1作为旁路由(自定义网关，推荐)</strong></h4><ul>
<li><p>光猫(192.168.1.1)–&gt;主路由器网关(192.168.68.1)—&gt;N1网关(192.168.68.99)<br>其他电脑也连接主路由</p>
</li>
<li><p>首先无需设置主路由, 只需要设置N1的LAN后, 方法网络-接口-LAN<br>传输协议: 静态地址<br>IPv4地址: 192.168.68.99<br>IPv4子网掩码: 255.255.255.0<br>IPv4网关: 192.168.68.1 (你的主路由地址)<br>IPv4广播: 无需设置<br>自定义DNS: 可以根据自己的需要设置<br>IPv6 分配长度: 可以保存默认</p>
</li>
<li><p>下面的基本设置<br><strong>忽略此接口(一定要选择, 也就是说不在N1上不启用DHCP服务)</strong></p>
</li>
<li><p>IPv6设置:<br>路由通告服务: 停用<br>DHCPv6服务: 停用<br>NDP服务: 停用</p>
</li>
</ul>
<h4 id="N1作为旁路由-所有用户自动设置网关"><a href="#N1作为旁路由-所有用户自动设置网关" class="headerlink" title="N1作为旁路由(所有用户自动设置网关)"></a><strong>N1作为旁路由(所有用户自动设置网关)</strong></h4><ul>
<li><p>光猫(192.168.1.1)–&gt;主路由器(192.168.68.1)—&gt;N1网关(192.168.68.99)<br>其他电脑也连接主路由器</p>
</li>
<li><p>首先进主路由, 关闭DHCP, 具体参考主路由后台, 每家的页面可能不一样.</p>
</li>
<li><p>再设置N1的LAN后, 方法网络-接口-LAN<br>传输协议: 静态地址<br>IPv4地址: 192.168.68.99<br>IPv4子网掩码: 255.255.255.0<br>IPv4网关: 192.168.68.1 (你的主路由地址)<br>IPv4广播: 无需设置<br>自定义DNS: 可以根据自己的需要设置<br>IPv6 分配长度: 可以保存默认<br>下面的基本设置可以参考截图.<br><strong>最重要的就是必须在高级设置里面启动动态DHCP</strong></p>
</li>
<li><p>IPv6设置:<br>路由通告服务: 停用<br>DHCPv6服务: 停用<br>NDP服务: 停用</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.openos.org/threads/n1.1248/">https://www.openos.org/threads/n1.1248/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Nginx 入门之-配置密码访问：访问网页需输入用户名密码</title>
    <url>/p/cfebe32b/</url>
    <content><![CDATA[<p>需要实现的需求如下：</p>
<p>使用 Nginx 做 web 服务，但由于安全问题需求，访问网页时需要输入用户名和密码进行认证。</p>
<h3 id="1-安装密码生成工具"><a href="#1-安装密码生成工具" class="headerlink" title="1. 安装密码生成工具"></a>1. 安装密码生成工具</h3><pre><code>$ yum  -y install httpd-tools
</code></pre>
<h3 id="2-生成用户和密码文件"><a href="#2-生成用户和密码文件" class="headerlink" title="2. 生成用户和密码文件"></a>2. 生成用户和密码文件</h3><p>生成用户和密码</p>
<pre><code>$ htpasswd -c $PWD/password/password.db this-is-user-name
# 回车后输入密码
# -c 创建一个加密文件
# 查看生成的用户和密码
cat password/password.db
</code></pre>
<p>如果要修改密码，或者删除密码，请参考下面操作</p>
<p>删除用户和密码</p>
<pre><code>$ htpasswd -D /usr/local/nginx/password username
# -D 删除指定的用户
# 修改用户和密码

$ htpasswd -D /usr/local/nginx/password username
$ htpasswd -b /usr/local/nginx/password username pass
# -D 删除指定的用户
# -b htpassswd命令行中一并输入用户名和密码而不是根据提示输入密码
# -p htpassswd命令不对密码进行进行加密，即明文密码
</code></pre>
<h3 id="3-配置-Nginx-认证"><a href="#3-配置-Nginx-认证" class="headerlink" title="3. 配置 Nginx 认证"></a>3. 配置 Nginx 认证</h3><p>找到 nginx 配置文件，通常默认的配置文件在/usr/local/nginx/conf/nginx.conf，要对整个站点开启验证，需在配置文件中的server加上认证配置<br>如果是 docker 安装映射了 /etc/nginx/conf.d 目录的话，需要在指定的 .conf 文件内加上认证配置<br>auth_basic 和 auth_basic_user_file</p>
<pre><code>server &#123;
  listen 80;
  server_name  localhost;
  # ...
  
  auth_basic &quot;请输入用户和密码&quot;; # 验证时的提示信息
  auth_basic_user_file /etc/nginx/password/password.db; # 认证文件

  location / &#123;
     #...  忽略
  &#125;
  # ...
&#125;
</code></pre>
<h3 id="4-重启-重载Nginx使站点的认证生效"><a href="#4-重启-重载Nginx使站点的认证生效" class="headerlink" title="4. 重启/重载Nginx使站点的认证生效"></a>4. 重启/重载Nginx使站点的认证生效</h3><pre><code>/usr/local/nginx/sbin/nginx -s reload
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000023086569">Nginx配置密码访问-访问网页需输入用户名密码</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 安装 nginx</title>
    <url>/p/b0add2d0/</url>
    <content><![CDATA[<h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><pre><code class="bash">docker run --name nginx_3000 -p 3000:80 -d nginx
</code></pre>
<h2 id="直接访问-localhost-3000-即可打开-nginx-配置成功页面"><a href="#直接访问-localhost-3000-即可打开-nginx-配置成功页面" class="headerlink" title="直接访问 localhost:3000 即可打开 nginx 配置成功页面"></a>直接访问 localhost:3000 即可打开 nginx 配置成功页面</h2><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><h3 id="创建链接目录"><a href="#创建链接目录" class="headerlink" title="创建链接目录"></a>创建链接目录</h3><p>root目录下</p>
<pre><code class="bash">root@DESKTOP-91MGDB0:~# pwd
/root
root@DESKTOP-91MGDB0:~# mkdir -p nginx/logs
root@DESKTOP-91MGDB0:~# mkdir -p nginx/html
root@DESKTOP-91MGDB0:~# mkdir -p nginx/conf
</code></pre>
<h3 id="使用-docker-compose-yml-文件"><a href="#使用-docker-compose-yml-文件" class="headerlink" title="使用 docker-compose.yml 文件"></a>使用 docker-compose.yml 文件</h3><p>本文是wsl2安装</p>
<pre><code class="bash">root@DESKTOP-91MGDB0:~/nginx# pwd
/root/nginx
root@DESKTOP-91MGDB0:~/nginx# cp /mnt/c/Users/lenovo/Desktop/docker-compose.yml docker-compose.yml
</code></pre>
<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>建议把 docker-compose.yml 文件放在 nginx 目录下</p>
<pre><code class="yml">version: &quot;3&quot;
services:
  nginx:
    image: nginx:latest
    restart: always
    container_name: nginx
    hostname: 127.0.0.1
    ports:
      - 80:80
    volumes:
      - $PWD/nginx.conf:/etc/nginx/nginx.conf # nginx 主配置文件，includes /etc/nginx/conf.d 里的配置文件
      - $PWD/logs:/var/log/nginx # nginx 相关日志
    #   - /root/nginx/html:/usr/share/nginx/html
      - /mnt/c/workspace/blog/chgocn.github.io/public:/usr/share/nginx/html # nginx 配置的 webapp 的目录
      - $PWD/conf:/etc/nginx/conf.d # nginx server 代码块配置文件
      - $PWD/password:/etc/nginx/password # 使用 httpd-tools 设置网页认证访问
</code></pre>
<h3 id="拉取镜像并启动容器"><a href="#拉取镜像并启动容器" class="headerlink" title="拉取镜像并启动容器"></a>拉取镜像并启动容器</h3><pre><code class="bash">docker pull nginx &amp; docker-compse up -d
</code></pre>
<h3 id="导出-nginx-容器内连接的文件和目录"><a href="#导出-nginx-容器内连接的文件和目录" class="headerlink" title="导出 nginx 容器内连接的文件和目录"></a>导出 nginx 容器内连接的文件和目录</h3><pre><code class="bash">root@DESKTOP-91MGDB0:~/nginx# docker cp nginx:/etc/nginx/nginx.conf nginx.conf
root@DESKTOP-91MGDB0:~/nginx# docker cp nginx:/usr/share/nginx/html ./
root@DESKTOP-91MGDB0:~/nginx# docker cp nginx:/etc/nginx/conf.d ./conf/
</code></pre>
<h3 id="重新更新docker-compose-yml-文件并重新创建容器"><a href="#重新更新docker-compose-yml-文件并重新创建容器" class="headerlink" title="重新更新docker-compose.yml 文件并重新创建容器"></a>重新更新docker-compose.yml 文件并重新创建容器</h3><pre><code class="bash">root@DESKTOP-91MGDB0:~/nginx# cp /mnt/c/Users/lenovo/Desktop/docker-compose.yml docker-compose.yml
root@DESKTOP-91MGDB0:~/nginx# docker-compose up -d
</code></pre>
<h3 id="docker-使用注意"><a href="#docker-使用注意" class="headerlink" title="docker 使用注意"></a>docker 使用注意</h3><ul>
<li>不支持直接挂载文件，只能挂载文件夹</li>
<li>想要挂载文件，必须宿主机也要有对应的同名文件</li>
</ul>
<p>解决方案：<br>可以先不挂载 nginx.conf 文件<br>先从容器中复制 nginx.conf 出来<br>然后可以自行修改 nginx.conf，自定义配置项<br>创建正式使用的 nginx 容器</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 入门之-反向代理实现二级域名转发</title>
    <url>/p/849e798f/</url>
    <content><![CDATA[<h2 id="第一步-域名云解析，添加-DNS-记录"><a href="#第一步-域名云解析，添加-DNS-记录" class="headerlink" title="第一步 域名云解析，添加 DNS 记录"></a>第一步 域名云解析，添加 DNS 记录</h2><p>阿里云、腾讯云、华为云等都可以进行云解析；这里以cloudflare为例。</p>
<p>cloudflare解析<br><img src="" alt="cloudflare解析"></p>
<h2 id="第二步-在-Nginx-中完成反向代理配置"><a href="#第二步-在-Nginx-中完成反向代理配置" class="headerlink" title="第二步 在 Nginx 中完成反向代理配置"></a>第二步 在 Nginx 中完成反向代理配置</h2><p>编辑 Nginx 配置文件，在 nginx.conf 文件中新增server节点如下（通过vi /etc/nginx/nginx.conf修改）<br>或 在映射的 conf 目录下创建 xxx.conf 文件（/etc/nginx/nginx.conf 中 通过 inclue server.conf 中实现），新增以下内容</p>
<pre><code>server &#123;
    listen 80;
    server_name www.chgocn.ml;
    location / &#123;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $http_host;
        proxy_pass https://127.0.0.1:80;
    &#125;
&#125;

# 通过 nginx 反向代理 github pages
server &#123;
    listen 80;
    server_name blog.chgocn.com;
    location / &#123;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $http_host;
        proxy_pass https://chgocn.github.io;
    &#125;
&#125;
</code></pre>
<h2 id="第三步-验证二级域名"><a href="#第三步-验证二级域名" class="headerlink" title="第三步 验证二级域名"></a>第三步 验证二级域名</h2><p>切记，验证之前先要使用nginx -s reload刷新 Nginx 配置。<br>使用 docker 安装的 nginx，可以 docker restart nginx</p>
<h2 id="Notes："><a href="#Notes：" class="headerlink" title="Notes："></a>Notes：</h2><p>建议80端口（HTTP默认端口）分配给Nginx来监听，便于实现对入站请求的统一拦截；<br>在云解析添加 DNS 记录后，可能需要等几分钟，添加的二级域名解析才会生效，一般为 10 分钟左右；<br>至此，基于 Nginx 的反向代理，实现了二级域名的转发，下一篇再去了解下Nginx负载均衡。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://heartsuit.github.io/2019/04/30/Nginx-Reverse-Proxy-Server.html">入门Nginx之-反向代理实现二级域名转发</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Openwrt使用KMS服务器的使用</title>
    <url>/p/8938d84a/</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>用来激活window以及office。</p>
<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><h3 id="WINDOWS"><a href="#WINDOWS" class="headerlink" title="WINDOWS"></a>WINDOWS</h3><p>1、第一步、打开DOS或powershell，输入<strong>slmgr /upk</strong>，卸载WINDOWS自带密钥</p>
<p>2、第二步、输入<strong>slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</strong></p>
<p>(在上面key列表选择对应版本的Key，也可以搜索找对应版本key)</p>
<p><strong>安装对应密钥</strong></p>
<p>常用Windows VL版KMS激活密钥列表：</p>
<p>Win10专业版KMS： W269N-WFGWX-YVC9B-4J6C9-T83GX</p>
<p>Win10企业版KMS： NPPR9-FWDCX-D2C8J-H872K-2YT43</p>
<p>Win10LTSB版KMS： DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ</p>
<p>Win10家庭版KMS： TX9XD-98N7V-6WMQ6-BX7FG-H8Q99</p>
<p>Win10教育版KMS： NW6C2-QMPVW-D7KKK-3GKT6-VCFB2</p>
<p>Win7专业版KMS： FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4</p>
<p>Win7企业版KMS： 33PXH-7Y6KF-2VJC9-XBBR8-HVTHH</p>
<p>3、第三步、<strong>slmgr /skms 192.168.68.99</strong>（openwrt路由器IP地址）</p>
<p>4、<strong>第四步、slmgr /ato</strong></p>
<h3 id="OFFICE激活"><a href="#OFFICE激活" class="headerlink" title="OFFICE激活"></a>OFFICE激活</h3><p>1、第一步、找到你的OFFICE目录</p>
<p>我的是OFFICE 2016 32位版，目录为：</p>
<p>C:\Program Files (x86)\Microsoft Office\Office16</p>
<p>进去这个目录，可以看见有个OSPP.VBS文件</p>
<p>如果是OFFICE 2016 64位版，目录应为：</p>
<p>C:\Program Files\Microsoft Office\Office16</p>
<p>2、<strong>第二步、powershell中cd “C:\Program Files (x86)\Microsoft Office\Office16”（双引号中对应你的实际目录）</strong></p>
<p>3、第三步、输入<strong>cscript ospp.vbs /sethst:192.168.50.1</strong>（你的路由IP）</p>
<p>4、第四步、输入<strong>cscript ospp.vbs /act</strong></p>
<p>接下来享受激活的WINDOWS和OFFICE吧（使用系统自身批处理命令激活，因此不可能有后门，不用担心病毒和信息窃取之类的）。如果失败，请检查WINDOWS和OFFICE具体版本信息。</p>
]]></content>
  </entry>
  <entry>
    <title>中文输出乱码的一些总结</title>
    <url>/p/b68ec802/</url>
    <content><![CDATA[<h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><pre><code class="powershell">chcp 65001
</code></pre>
<h3 id="Git-bash"><a href="#Git-bash" class="headerlink" title="Git bash"></a>Git bash</h3><pre><code class="bash">chcp.com 65001
</code></pre>
<h3 id="Windows-运行-Python"><a href="#Windows-运行-Python" class="headerlink" title="Windows 运行 Python"></a>Windows 运行 Python</h3><pre><code>winpty python -u test.py
</code></pre>
<h3 id="Windows-cmd"><a href="#Windows-cmd" class="headerlink" title="Windows cmd"></a>Windows cmd</h3><pre><code>chcp 65001
</code></pre>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>Svn、Git、Dropbox、Onedrive Overlay Icon显示异常处理</title>
    <url>/p/d30ca237/</url>
    <content><![CDATA[<p>Windows Explorer Shell 支持的 Overlay Icon 最多 15 个，Windows 内部就是按图标名称的字母顺序来优先显示的，我们可以调整优先级。</p>
<span id="more"></span>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol>
<li>删除其他软件。(软件不在于多，而在于精)</li>
<li>修改注册表优先级。<br>window + r -&gt; regedit<br>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers如下图<br><img src="http://7vik6r.com1.z0.glb.clouddn.com/SVN%E6%8D%95%E8%8E%B7.PNG" alt="enter image description here"> </li>
</ol>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>pdf 文档去水印以及将A3页面分割成A4页面</title>
    <url>/p/99e81533/</url>
    <content><![CDATA[<p>网上找到一个说明书，但是说明书中被添加了水印，记录如何去水印</p>
<p><a href="https://qcloudcos.pptbest.com/xunjiepdf/temp/20220328/840d5ed92e134a51a9cd1e1341b11038/20210709132331162580821126633.pdf">示例pdf下载地址</a></p>
<h2 id="pdf-移除水印"><a href="#pdf-移除水印" class="headerlink" title="pdf 移除水印"></a>pdf 移除水印</h2><p><a href="https://www.pdf2everything.com/pdflink/">https://www.pdf2everything.com/pdflink/</a></p>
<p>这里是移除pdf中的水印链接，选中PDF Link Editor，在弹出的页面输入 URL ，上传原pdf文件，点击 Start 即可。</p>
<p><img src="https://os-buket.oss-cn-hangzhou.aliyuncs.com/img/image-20220328153401371.png"></p>
<h2 id="pdf-A3页面-分割成-A4"><a href="#pdf-A3页面-分割成-A4" class="headerlink" title="pdf A3页面 分割成 A4"></a>pdf A3页面 分割成 A4</h2><p><a href="https://www.sejda.com/">https://www.sejda.com/</a></p>
<p>在 All Tools 中 找到 split in half，上传 pdf 文件即可。</p>
]]></content>
  </entry>
  <entry>
    <title>windows 下各个软件的代理设置</title>
    <url>/p/4d799774/</url>
    <content><![CDATA[<p>以本地代理，端口为7890为例。</p>
<pre><code class="bash"># 设置http代理
git config --global http.proxy http://127.0.0.1:7890
git config --global https.proxy https://127.0.0.1:7890

# 设置socks代理
git config --global http.proxy &#39;socks5://127.0.0.1:7890&#39;
git config --global https.proxy &#39;socks5://127.0.0.1:7890&#39;

# 取消代理
git config --global --unset http.proxy
git config --global --unset https.prox
</code></pre>
<pre><code class="bash"># 设置代理
set http_proxy=http://127.0.0.1:7890
set https_proxy=http://127.0.0.1:7890

# 移除代理
set http_proxy=
set https_proxy=

# 验证
curl -vv http://www.google.com
</code></pre>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3的日常使用</title>
    <url>/p/python/</url>
    <content><![CDATA[<p>主要介绍<a href="https://www.python.org/">Python3</a>在日常使用中的一些Tips。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><pre><code class="bash">PYTHON_HOME
%PYTHON_HOME%/scripts
</code></pre>
<h3 id="pip-相关命令"><a href="#pip-相关命令" class="headerlink" title="pip 相关命令"></a>pip 相关命令</h3><h4 id="依赖管理pip"><a href="#依赖管理pip" class="headerlink" title="依赖管理pip"></a>依赖管理<a href="https://pip.pypa.io/en/stable/cli/">pip</a></h4><p>安装依赖和写在依赖</p>
<pre><code class="bash">pip install googletrans
pip uninstall googletrans
</code></pre>
<h4 id="查看安装的依赖"><a href="#查看安装的依赖" class="headerlink" title="查看安装的依赖"></a>查看安装的依赖</h4><pre><code>pip list
pip freeze -r requirenment.txt #方便迁移环境
pip install -r requirenment.txt #一键安装所有依赖
</code></pre>
<h3 id="pip-源"><a href="#pip-源" class="headerlink" title="pip 源"></a>pip 源</h3><p>例：pip install googletrans -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>清华大学</p>
<pre><code>https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<p>阿里云</p>
<pre><code>http://mirrors.aliyun.com/pypi/simple/
</code></pre>
<p>腾讯云</p>
<pre><code>https://mirrors.cloud.tencent.com/pypi/simple/
</code></pre>
<p>中国科技大学</p>
<pre><code>https://mirrors.cloud.tencent.com/pypi/simple/
</code></pre>
<p>豆瓣</p>
<pre><code>https://pypi.doubanio.com/simple/
</code></pre>
<p>浙江大学</p>
<pre><code>https://mirrors.zju.edu.cn/pypi/web/simple/
</code></pre>
<h3 id="第三方模块-virtualenv"><a href="#第三方模块-virtualenv" class="headerlink" title="第三方模块 virtualenv"></a>第三方模块 virtualenv</h3><pre><code>pip install virtualenv
virtualenv venv
source venv/Scripts/activate
</code></pre>
<h3 id="使用-vscode-调试python-virtualenv"><a href="#使用-vscode-调试python-virtualenv" class="headerlink" title="使用 vscode 调试python virtualenv"></a>使用 vscode 调试python virtualenv</h3><ul>
<li>在 VS Code 选择 “查看 &gt; 命令面板” 或按下 “Ctrl + Shift + P” 来打开命令面板</li>
<li>再选择 Python:Select Interpreter 来选择运行环境</li>
</ul>
<pre><code>&#123;
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        &#123;
            &quot;name&quot;: &quot;Python: 当前文件&quot;,
            &quot;type&quot;: &quot;python&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;tools/static_trainer.py&quot;,
            &quot;console&quot;: &quot;integratedTerminal&quot;,
            &quot;args&quot;: [
                
                &quot;-m&quot;,
                &quot;models/demo/movie_recommand/recall/movie.yaml&quot;
            ]
        &#125;
    ]
&#125;
</code></pre>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/weixin_44613063/article/details/88563752">VS Code中运行Python的虚拟环境</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
  </entry>
  <entry>
    <title>rust 使用</title>
    <url>/p/b23e24f8/</url>
    <content><![CDATA[<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul>
<li>vscode</li>
<li>插件 rust-analyzer</li>
<li>CodeLLDB</li>
</ul>
<h3 id="rust-中文源"><a href="#rust-中文源" class="headerlink" title="rust 中文源"></a>rust 中文源</h3><p>vi ~/.cargo/config</p>
<pre><code># 放到 `$HOME/.cargo/config` 文件中
[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;

# 替换成你偏好的镜像源
replace-with = &#39;sjtu&#39;
#replace-with = &#39;ustc&#39;

# 清华大学
[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;

# 中国科学技术大学
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;

# 上海交通大学
[source.sjtu]
registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;

# rustcc社区
[source.rustcc]
registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;

[net]
git-fetch-with-cli=true
</code></pre>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ul>
<li>中文 \x34 编码文字 转 utf-8<pre><code class="rust">String::from_utf8(bytes.to_vec());
</code></pre>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Rust 学习笔记：package/crate/module</title>
    <url>/p/394511ee/</url>
    <content><![CDATA[<p>文章转载: <a href="http://liubin.org/blog/2021/01/19/packages-slash-crate-slash-modules-in-rust/">http://liubin.org/blog/2021/01/19/packages-slash-crate-slash-modules-in-rust/</a></p>
<p>cargo new 会生成项目的雏形，提供了src/main.rs和src/lib.rs文件，但是随着项目的增长，代码的量也会变大，靠一个文件维护一大堆代码，肯定是不合适的。这时候一般都会按“模块”来拆分文件，=rust=也不例外。</p>
<p>这里学习一下=rust=中代码的组织方式，主要涉及到以下几个概念：</p>
<ul>
<li>package：Cargo中的概念，管理crate</li>
<li>crate：模块的集合，编译单位，有lib和bin两种，即供别人调用，或者是一个可执行文件</li>
<li>module：用于在crate内组织代码</li>
<li>workspace：项目复杂时，管理多个package</li>
</ul>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>cargo new 命令会创建一个新项目，也是一个package，里面有一个Cargo.toml文件，用于定义package、所需外部依赖，以及如何编译crate等。</p>
<h2 id="crate"><a href="#crate" class="headerlink" title="crate"></a>crate</h2><p>=rust=里有两种crate，lib类型和bin类型，并且默认以文件名为标准按以下规则处理crate：</p>
<ul>
<li>src/main.rs：表示该crate是一个bin类型的crate</li>
<li>src/lib.rs：表示该crate是一个lib类型的crate</li>
</ul>
<p>src/main.rs和src/lib.rs都是crate的根，也就是crate引用、=rust=c编译的入口。</p>
<p>此外，一个package中的crate还有如下约束：</p>
<ol>
<li>多个bin类型的crate</li>
<li>0个或1个lib类型的crate</li>
</ol>
<p>其中，1和2并不互斥，也就是说一个项目下可以有1个lib和多个bin类型的crate，即一个package还以编译出多个可执行文件。</p>
<p>只是如果有多个bin类型的crate，一个src/main.rs就不行了，就得放到 src/bin 下面，每个crate一个文件，换句话说，每个文件都是一个不同的crate。</p>
<h2 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h2><p>代码多了可以对代码以mod（文件/文件夹）为单位进行拆分，而不必把所有代码都写在src/lib.rs或者src/main.rs里。</p>
<p>以lib类型的crate为例，该crate的入口在src/lib.rs，也是crate的根。在 src/lib.rs 里定义模块很简单：</p>
<p>|  |</p>
<pre><code>mod mymod &#123;
    fn test() &#123;
        println!(&quot;test&quot;);
    &#125;
&#125;
</code></pre>
<p>|<br>| – | ————————————————————————- |</p>
<p>而实际项目中，我们都不可能只有一个lib.rs文件，而是会将代码按功能等拆分为多个模块。</p>
<h3 id="模块拆分"><a href="#模块拆分" class="headerlink" title="模块拆分"></a>模块拆分</h3><p>一般来说，一个文件都会被视为一个mod，而且mod可以嵌套定义。嵌套定义的mod既可以写在同一个文件里，也可以通过文件夹的形式来实现。</p>
<p>具体我们来看几个例子。</p>
<p>假设当前项目文件结构如下：</p>
<p>|  |</p>
<pre><code>src
├── lib.rs
├── mod_a
│   ├── mod.rs
│   └── mod_b.rs
└── mod_c.rs
</code></pre>
<p>|<br>| – | ————————————————————————————————– |</p>
<p>这里显示定义了3个mod：mod_a、mod_b和mod_c，其中mod_a为文件夹形式，而mod b 和mod c都有对应的文件。其中mod_b是mod_a的子模块。</p>
<p>我们来看一下各个模块是怎么声明的，以及应该如何引用。</p>
<p>首先来看一下crate的根，也就是入口lib.rs：</p>
<p>|  |</p>
<pre><code>pub mod mod_a;
mod mod_c;
</code></pre>
<p>|<br>| – | ————————————- |</p>
<p>这里声明了两个mod，如果需要在crate外部访问，可以在mod前面加上pub关键字。注意这里不需要声明mod_a的子模块mod_c，这个需要由mod_a来声明。</p>
<p>再来看一下这两个mod。先看mod_a，这是一个文件夹形式存在的mod，按cargo规定，这时候需要在该文件夹下有一个名为mod.rs的文件定义该mod下的内容。该文件内容如下：</p>
<p>|  |</p>
<pre><code>// src/mod_a/mod.rs
pub mod mod_b;
</code></pre>
<p>|<br>| – | ———————————————- |</p>
<p>可以看到，这个文件和lib.rs类似，都可以声明mod。该文件声明的mod_b的代码则保存为mod_b.rs：</p>
<p>|  |</p>
<pre><code>// src/mod_a/mod_b.rs
use super::super::mod_c;

pub fn test() &#123;
    println!(&quot;i&#39;m mod_b&quot;);
&#125;

fn call_mod_c() &#123;
    mod_c::test();
&#125;
</code></pre>
<p>|<br>| – | ———————————————————————————————————————————————— |</p>
<p>再来看一下mod_c的代码：</p>
<p>|  |</p>
<pre><code>// src/mod_c.rs
use crate::mod_a::mod_b;

pub fn test() &#123;
    mod_b::test();
    println!(&quot;i&#39;, mod_c&quot;);
&#125;
</code></pre>
<p>|<br>| – | ——————————————————————————————————————— |</p>
<p>除了如何定义mod，还需要注意的是如何引用其他mod的定义。这里在mod_c中，要想使用mod_b，可以使用 <strong>use crate::mod_a::mod_b</strong> 这种绝对路径形式。</p>
<p>而在mod_b中使用mod_c的时候，使用了 <strong>use super::super::mod_c</strong> 这种先对路径的形式。</p>
<h3 id="添加main-rs"><a href="#添加main-rs" class="headerlink" title="添加main.rs"></a>添加main.rs</h3><p>最后在上面代码的基础上添加一下main.rs，看看如何作为外部crate使用上面的mod_a。</p>
<p>|  |</p>
<pre><code>// src/main.rs
use testlib::mod_a::mod_b;

fn main() &#123;
    println!(&quot;main&quot;);
    mod_b::test();
&#125;
</code></pre>
<p>|<br>| – | ————————————————————————————————————- |</p>
<p>这里唯一想要提醒的就是lib的引用方法，不能使用crate开头的绝对路径或者相对路径引用方式，必须使用该crate的名称（也就是Cargo.toml里的名称，本例为testlib）来引用。因为main和lib分别属于不同的crate。</p>
<p>假如将上面的testlib改为crate，编译器会报如下错误：</p>
<p><img src="http://liubin.org/images/2021/01/rust-compile-error.png" title="&#39;编译错误&#39;"></p>
<p>很多时候编译器都是我们最好的老师。</p>
<h3 id="pub修饰符"><a href="#pub修饰符" class="headerlink" title="pub修饰符"></a>pub修饰符</h3><h4 id="结构体和枚举"><a href="#结构体和枚举" class="headerlink" title="结构体和枚举"></a>结构体和枚举</h4><p>要想访问其他mod里的结构体，需要将结构体声明为pub，但是这也只能访问到结构体而已，如果要想操作里面的字段，可以有两种方式：</p>
<ul>
<li>提供pub的方法修改字段</li>
<li>将需要操作的字段直接修改为pub类型</li>
</ul>
<p>可能前者更“面向对象”一些。</p>
<p>而枚举类型的话只需要在枚举名前面加上pub即可，不需要对其中的variant进行设置。</p>
<h2 id="use语句"><a href="#use语句" class="headerlink" title="use语句"></a>use语句</h2><p>讲了这么多基础概念，下面看一下如何使用。</p>
<p>在crate和模块了可能定义了函数、结构体等，要想在其他模块或crate使用，需要将其引入到当前scope中，类似java的import的功能，=rust=里需要使用use。</p>
<p>如何表示要被引用的对象（=rust=中称为item），=rust=里称之为path，可以理解为我们在操作系统里使用文件一下。</p>
<p>=rust=中path有两种形式，也跟文件系统一样，绝对路径和相对路径：</p>
<ul>
<li>绝对路径始于crate的根（src/main.rs或src/lib.rs），可以使用crate名或者crate这个字面值表示</li>
<li>相对路径可以使用当前模块名、当前模块中可以使用的对象，super和self等。</li>
</ul>
<p>path中的层级使用两个冒号，类似文件系统中的斜线。</p>
<p>假设有如下代码（来自trpl）：</p>
<p>|  |</p>
<pre><code>mod front_of_house &#123;
    pub mod hosting &#123;
        pub fn add_to_waitlist() &#123;&#125;
    &#125;
&#125;

pub fn eat_at_restaurant() &#123;
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
&#125;
</code></pre>
<p>|<br>| – | ———————————————————————————————————————————————————————————————————————————————————————————— |</p>
<p>上面的第9行就是绝对路径形式的引用，而第12行就是相对路径的引用，这里，front_of_house处于crate的根之下，而不是位于其他子模块之下。</p>
<p>有一些限制需要知道：</p>
<ul>
<li>在父模块中不能使用子模块中的private项目</li>
<li>子模块可以使用父模块中的所有item</li>
</ul>
<p>注意 front_of_house 模块虽然不是pub的，但是eat_at_restaurant却可以使用，因为他们在同一模块下，这不需要pub就可以使用，否则所有item都只能变成pub才能使用了。但是hosting模块和add_to_waitlist方法必须为pub类型的，否则就不能从他们的父模块中的项目中使用了。</p>
<p>下面是一个使用了super的例子：</p>
<p>|  |</p>
<pre><code>fn serve_order() &#123;&#125;

mod back_of_house &#123;
    fn fix_incorrect_order() &#123;
        cook_order();
        super::serve_order();
    &#125;

    fn cook_order() &#123;&#125;
&#125;
</code></pre>
<p>|<br>| – | ———————————————————————————————————————————————————————– |</p>
<p>fix_incorrect_order方法属于back_of_house模块，要调用的serve_order和back_of_house同级，因此在back_of_house模块中的函数里，可以使用super::serve_order，访问到该模块同级的serve_order方法。</p>
<p>如果use后面的路径具有具有共同的父路径，可以使用简化的模式。比如 ：</p>
<p>|  |</p>
<pre><code>use std::io;
use std::cmp::Ordering;
</code></pre>
<p>|<br>| – | ———————————————— |</p>
<p>可以简化为：</p>
<p>|  |</p>
<pre><code>use std::&#123;cmp::Ordering, io&#125;;
</code></pre>
<p>|<br>| – | —————————————– |</p>
<p>如果同时use的mod之间有父子关系，也可以像上面那样简化，使用self代表父mod。比如：</p>
<p>|  |</p>
<pre><code>use std::io;
use std::io::Write;
</code></pre>
<p>|<br>| – | ——————————————– |</p>
<p>可以简化为：</p>
<p>|  |</p>
<pre><code>use std::io::&#123;self, Write&#125;;
</code></pre>
<p>|<br>| – | ————————————— |</p>
<p>如果想将某一路径下的所有public的item都引入到当前scope中，可以使用<code>*</code>。</p>
<p>|  |</p>
<pre><code>use std::collections::*;
</code></pre>
<p>|<br>| – | ———————————— |</p>
<p>一般业务代码文件内的单元测试中常用：</p>
<p>|  |</p>
<pre><code>#[cfg(test)]
mod tests &#123;
    use super::*;
    #[test]
    fn it_works() &#123;
    &#125;
&#125;
</code></pre>
<p>|<br>| – | ———————————————————————————————- |</p>
<p>这样在单测mod中，可以使用父mod中的所有item。</p>
<h3 id="引用层级"><a href="#引用层级" class="headerlink" title="引用层级"></a>引用层级</h3><p>对比两段代码：</p>
<p>|  |</p>
<pre><code># case 1
use crate::front_of_house::hosting;
hosting::add_to_waitlist();

# case 2
use crate::front_of_house::hosting::add_to_waitlist;
add_to_waitlist();
</code></pre>
<p>|<br>| – | ———————————————————————————————————————————————————————- |</p>
<p>这两种方法结果一样，但是阅读起来给人的感觉是不一样的。一般来说推荐前者，因为这样可以明确的知道使用的方法是外部的hosting模块的方法，后者的话则不知道该方法是use进来的，还是本模块定义的。</p>
<h3 id="名称冲突"><a href="#名称冲突" class="headerlink" title="名称冲突"></a>名称冲突</h3><p>有的时候可能从不同的crate或者mod引入了同名的item，这时候最简单的方式是使用 as 关键字进行重命名。</p>
<p>|  |</p>
<pre><code>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result &#123;
&#125;

fn function2() -&gt; io::Result&lt;()&gt; &#123;
&#125;


use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result &#123;
&#125;

fn function2() -&gt; IoResult&lt;()&gt; &#123;
&#125;
</code></pre>
<p>|<br>| – | —————————————————————————————————————————————————————————————————————————————— |</p>
<h3 id="re-exporting-再导出"><a href="#re-exporting-再导出" class="headerlink" title="re-exporting 再导出"></a>re-exporting 再导出</h3><p>当使用use关键字将外部item导入到当前scope之后，这个item在当前scope是private的，如果使用 pub use 的话，还能让使用当前mod的第三者，使用在该mod中引入的item。</p>
<p>该机制称为 re-exporting 。</p>
<h2 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h2><p>workspace用于管理多个相关的package，不同的package有各自的Cargo.toml，但是整个workspace共享一个Cargo.lock，也只有一个target目录（编译输出）。</p>
<p>虽然workspace内的项目共享一个Cargo.lock，但是他们之间默认不互相依赖，需要显示添加它们之间的依赖关系。而且在一个项目中添加的依赖，在其他项目中如果想使用，还需要再次声明依赖才行。</p>
<p>不过据我观察workspace功能没有什么特别强大之处，不使用该功能也可以同时管理几个Cargo项目，因此这里就不再深入介绍了。</p>
]]></content>
  </entry>
  <entry>
    <title>git/ssh 简述</title>
    <url>/p/bdc4320e/</url>
    <content><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>检查PC端是否存在ssh,如果不存在就创建一个类型为rsa，并且注释为“<a href="mailto:&#120;&#x78;&#120;&#64;&#x78;&#x78;&#x78;&#x2e;&#99;&#x6f;&#x6d;">&#120;&#x78;&#120;&#64;&#x78;&#x78;&#x78;&#x2e;&#99;&#x6f;&#x6d;</a>”的ssh密钥。复制密钥字符串。最后当然是在服务端添加一个ssh key了。</p>
<pre><code>cat ~/.ssh/id_rsa.pub
ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;
cat ~/.ssh/id_rsa.pub
Windows:
clip &lt; ~/.ssh/id_rsa.pub
Mac:
pbcopy &lt; ~/.ssh/id_rsa.pub
GNU/Linux (requires xclip):
xclip -sel clip &lt; ~/.ssh/id_rsa.pub
</code></pre>
<h2 id="SSH-UML"><a href="#SSH-UML" class="headerlink" title="SSH UML"></a>SSH UML</h2><p><img src="http://7vik6r.com1.z0.glb.clouddn.com/uml-blog-diagram-635054823354529732.png" alt="SSH UML"></p>
<h2 id="文件概述"><a href="#文件概述" class="headerlink" title="文件概述"></a>文件概述</h2><p>ssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥。<br>** ssh-keygen 选项 **</p>
<pre><code>-b：指定密钥长度；
-e：读取openssh的私钥或者公钥文件；
-C：添加注释；
-f：指定用来保存密钥的文件名；
-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；
-l：显示公钥文件的指纹数据；
-N：提供一个新密语；
-P：提供（旧）密语；
-q：静默模式；
-t：指定要创建的密钥类型。
</code></pre>
<ul>
<li><p>id_rsa和id_rsa_pub<br>调用ssh命令 ** ssh-keygen -t rsa -C “<a href="mailto:&#x78;&#120;&#x78;&#x40;&#x78;&#120;&#x78;&#x2e;&#x63;&#x6f;&#x6d;">&#x78;&#120;&#x78;&#x40;&#x78;&#120;&#x78;&#x2e;&#x63;&#x6f;&#x6d;</a>“ ** ，默认会生成id_rsa和id_rsa_pub两个文件。id_rsa是客户端的私有密钥文件，id_rsa_pub是客户端私有密钥根据一定的加密原则生成的公有密钥，保存于服务器。</p>
</li>
<li><p>当然如果要对多个服务端进行配置ssh，我们可以自定义生成的密钥文件名。调用**ssh-keygen -t rsa -f ~/.ssh/your_ssh_key_name -C “<a href="mailto:&#x78;&#x78;&#120;&#64;&#120;&#120;&#x78;&#x2e;&#x63;&#x6f;&#x6d;">&#x78;&#x78;&#120;&#64;&#120;&#120;&#x78;&#x2e;&#x63;&#x6f;&#x6d;</a>“ **，具体可以参考上述ssh-keygen命令。</p>
</li>
</ul>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1.** <a href="mailto:&#103;&#105;&#116;&#64;&#x78;&#120;&#120;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#x78;&#120;&#120;&#x2e;&#x63;&#x6f;&#x6d;</a> 输入密钥 **</p>
<p>当你键入 ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x78;&#120;&#x78;&#46;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x78;&#120;&#x78;&#46;&#x63;&#x6f;&#x6d;</a> 这条命令之后，程序提示要你输入 <a href="mailto:&#103;&#105;&#x74;&#x40;&#120;&#x78;&#120;&#x2e;&#x63;&#111;&#x6d;">&#103;&#105;&#x74;&#x40;&#120;&#x78;&#120;&#x2e;&#x63;&#111;&#x6d;</a> 的密码，那不用想了，程序没找到你的私有密钥。在哪些情况下会这样呢？</p>
<p>我们在生成这两个密钥的时候，程序可能没有帮我们在根目录下(C:/Users/yourName)新建一个 .ssh/ 文件夹，而他在建立连接的时候会默认寻找 ~/.ssh/id_rsa，如果没有新建一个这样的文件夹很显然是找不到的。你可以在根目录下通过命令行来新建一个文件夹</p>
<p>mkdir .ssh<br>之所以要用命令行是因为有时候浏览器不让你在文件夹名第一位放点号。</p>
<p>当然也有可能是因为你没有把创建的两个密钥放到 .ssh/ 目录下，而是直接扔在根目录下。</p>
<p>2.** Host key verification failed **</p>
<p>“Host key verification failed.” 相信你也撞到了这个问题，主机的密钥验证失败，主机就是你的机器，密钥验证失败有两个原因，一个是 RSA 做了更改，另一个原因是在 known_hosts 中存在一个缓存的记录，如果确认了 RSA 没有错误，那你就应该去 known_hosts 中删掉对应的那个记录（这个记录可以当做是缓存，是对验证做了一次缓存，缓存的作用是减少验证次数，不需要每次都验证，读取缓存就行了）。</p>
<p>当然，你也可以直接删除这个 known_hosts 文件。</p>
<p>3.** Permission denied (publickey) **</p>
<p>“Permission denied (publickey).” 这个问题其实和上面的 2 差不多，当你出现过 “Host key verification failed.”，然后继续执行程序，如执行 ssh -T <a href="mailto:&#103;&#105;&#116;&#x40;&#x78;&#x78;&#x78;&#46;&#x63;&#111;&#109;">&#103;&#105;&#116;&#x40;&#x78;&#x78;&#x78;&#46;&#x63;&#111;&#109;</a> 的时候就会出现这个问题提醒。说到底就是没有找到你的 rsa 私有密钥，或者 rsa 密钥匹配出错。</p>
<h2 id="Windows坑"><a href="#Windows坑" class="headerlink" title="Windows坑"></a>Windows坑</h2><p>1.** 找不到根目录 **</p>
<p>生成密钥默认放在 “<del>/.ssh/“ 下，但是在 cmd 下操作会找不到 “</del>/“ 这个根目录，因为这是 windows 不是 linux/unix，有些童鞋可能装了 cygwin，在这个环境下操作可以 “cd ~”，git bash 下当然也是可以的。</p>
<p>如果不知道有这个问题的存在，你会碰到上述问题一，程序直接让你输入密码，但不过你输入什么密码都是错误的。输入三次之后状态为 Permission denied，这里的原因就是没找到 ** <del>/.ssh/id_rsa ** ，cmd 下她根本就不认识 “</del>/“ 这个目录。</p>
<p>2.** 多个服务端的维护 **</p>
<p>很常见的问题。上面我们说到了，程序会默认寻找 ~/.ssh/id_rsa 这个文件，同一目录下显然不能有两个重名文件，也就是说当我们去认证 github 和另外一个 git 服务器的时候，我们需要把两个 rsa 私有密钥的名字换来换去，想用谁就把谁改成 id_rsa。特别麻烦，那肿么办？</p>
<p>之前在网上看到说是对 ssh_config 进行配置，配置内容是：</p>
<pre><code>Host github.com
    User boy-a
    IdentifyFile ~/.ssh/github
Host xxx.com
    User boy-b
    IdentifyFile ~/.ssh/xxx
</code></pre>
<p>这里的 “<del>/.ssh/github” 和 “</del>/.ssh/xxx” 都是 rsa 文件，文件的命令可以直接改，也可以在开始生成的时候设定，命名对内容没有任何影响。项目的几行代码应该也是十分清晰的，针对不同的 git 服务器，使用不用的 IdentifyFile。</p>
<p>但是你会发现，你的设置毫无用处，因为你把文件名搞错了！在 linux/unix 下可能是使用 ssh_config 这个文件名，但是在 windows 下是使用 config 作为文件名放在 ~/.ssh/ 目录中！</p>
<p>3.** 在某些CI环境中，按照上述方案处理了，依然报** Host key verification failed **错误。 **</p>
<p>这是因为在首次连接服务器时，会弹出公钥确认的提示。从而导致自动化任务中断。 SSH 客户端的 StrictHostKeyChecking 配置指令，可以实现当第一次连接服务器时，自动接受新的公钥。只需要修改 /your_user_name/.ssh/ssh_config 文件，包含下列语句：</p>
<pre><code>Host *
 StrictHostKeyChecking no
</code></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 3安装Sublime_Diagram_Plugin插件总结</title>
    <url>/p/3f0648c/</url>
    <content><![CDATA[<h2 id="Sublime-Diagram-Plugin地址"><a href="#Sublime-Diagram-Plugin地址" class="headerlink" title="Sublime_Diagram_Plugin地址"></a><a href="https://github.com/jvantuyl/sublime_diagram_plugin">Sublime_Diagram_Plugin</a>地址</h2><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><ol>
<li><a href="http://java.sun.com/">Java</a></li>
<li><a href="http://www.graphviz.org/Download_windows.php">Graphviz_Win</a></li>
<li><a href="https://www.sublimetext.com/">Sublime Text X</a></li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>unable to load diagram plugin,check console for details<br>解决方案：Graphviz安装到默认地址[C:\Program Files (x86)\Graphviz2.38]</p>
</blockquote>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>termux-ssh-pc</title>
    <url>/p/2a33dda2/</url>
    <content><![CDATA[<h3 id="Termux端"><a href="#Termux端" class="headerlink" title="Termux端"></a>Termux端</h3><pre><code>apt install openssh 或 pkg install openssh
sshd
apt install tsu        
tsu                         # 进行 root 授权
ifconfig                  # 查看ip
whoami                    # 如果不想用root账号登陆，可以查看当前用户名
passwd                    # 设置密码
echo &quot;sshd&quot; &gt;&gt; ~/.bashrc # 设置自启
</code></pre>
<h3 id="PC-端"><a href="#PC-端" class="headerlink" title="PC 端"></a>PC 端</h3><pre><code>ssh root@ip -p 8022 
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Sublime Text 3 安装与使用</title>
    <url>/p/1bb6c781/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="http://www.sublimetext.com/">官网地址</a></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>1、通用</p>
<pre><code>        Ctrl + Shift + P    调出命令板（Command Palette）
        Ctrl + `    调出控制台
</code></pre>
<p>2、编辑</p>
<pre><code>        Ctrl + Enter    在当前行下面新增一行然后跳至该行
        Ctrl + Shift + Enter    在当前行上面增加一行并跳至该行
        Ctrl + ←/→    进行逐词移动
        Ctrl + Shift + ←/→    进行逐词选择
        Ctrl + ↑/↓    移动当前显示区域
        Ctrl + Shift + ↑/↓    移动当前行
        Ctrl + Shift + D 复制当前行或当前代码块
</code></pre>
<p>3、选择</p>
<pre><code>        Ctrl + D    选择当前光标所在的词并高亮该词所有出现的位置，再次 Ctrl + D 选择该词出现的下一个位置，在多重选词的过程中，使用 Ctrl + K 进行跳过，使用 Ctrl + U 进行回退，使用 Esc 退出多重编辑
        Ctrl + Shift + L    将当前选中区域打散
        Ctrl + J    把当前选中区域合并为一行
        Ctrl + M    在起始括号和结尾括号间切换
        Ctrl + Shift + M    快速选择括号间的内容
        Ctrl + Shift + J    快速选择同缩进的内容
        Ctrl + Shift + Space    快速选择当前作用域（Scope）的内容
</code></pre>
<p>4、查找&amp;替换</p>
<pre><code>        F3    跳至当前关键字下一个位置
        Shift + F3    跳到当前关键字上一个位置
        Alt + F3    选中当前关键字出现的所有位置
        Ctrl + F/H    进行标准查找/替换，之后：
        Alt + C    切换大小写敏感（Case-sensitive）模式
        Alt + W    切换整字匹配（Whole matching）模式
        Alt + R    切换正则匹配（Regex matching）模式
        Ctrl + Shift + H    替换当前关键字
        Ctrl + Alt + Enter    替换所有关键字匹配
        Ctrl + Shift + F    多文件搜索&amp;替换
</code></pre>
<p>5、跳转</p>
<pre><code>        Ctrl + P    跳转到指定文件，输入文件名后可以：
        @ 符号跳转    输入@symbol跳转到symbol符号所在的位置
        # 关键字跳转    输入#keyword跳转到keyword所在的位置
        : 行号跳转    输入:12跳转到文件的第12行。
        Ctrl + R    跳转到指定符号
        Ctrl + G    跳转到指定行号
</code></pre>
<p>6、窗口</p>
<pre><code>        Ctrl + Shift + N    创建一个新窗口
        Ctrl + N    在当前窗口创建一个新标签
        Ctrl + W    关闭当前标签，当窗口内没有标签时会关闭该窗口
        Ctrl + Shift + T    恢复刚刚关闭的标签
</code></pre>
<p>7、屏幕</p>
<pre><code>        F11    切换至普通全屏
        Shift + F11    切换至无干扰全屏
        Alt+Shift+1       Single             切换至独屏
        Alt+Shift+2       Columns:2      切换至纵向二栏分屏
        Alt+Shift+3       Columns:3      切换至纵向三栏分屏
        Alt+Shift+4       Columns:4      切换至纵向四栏分屏
        Alt+Shift+8       Rows:2          切换至横向二栏分屏
        Alt+Shift+9       Rows:3          切换至横向三栏分屏
        Alt+Shift+5       Grid              切换至四格式分屏
</code></pre>
<h2 id="基础插件"><a href="#基础插件" class="headerlink" title="基础插件"></a>基础插件</h2><h3 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a><a href="https://packagecontrol.io/">Package Control</a></h3><ul>
<li>插件包控制器，用于管理插件，快捷键Ctrl + Shift + p。<blockquote>
<p>插件使用与安装: <a href="https://packagecontrol.io/installation">https://packagecontrol.io/installation</a></p>
</blockquote>
</li>
</ul>
<h2 id="常见插件"><a href="#常见插件" class="headerlink" title="常见插件"></a>常见插件</h2><h3 id="Sublime-Diagram-Plugin"><a href="#Sublime-Diagram-Plugin" class="headerlink" title="Sublime_Diagram_Plugin"></a><a href="https://github.com/jvantuyl/sublime_diagram_plugin">Sublime_Diagram_Plugin</a></h3><ul>
<li>PlantUML工具。</li>
<li>显示图形：Alt + D</li>
</ul>
<h3 id="Pretty-Json"><a href="#Pretty-Json" class="headerlink" title="Pretty Json"></a><a href="https://github.com/dzhibas/SublimePrettyJson">Pretty Json</a></h3><ul>
<li>格式化Json。<blockquote>
<p>快捷键 Ctrl + Alt + j。</p>
</blockquote>
</li>
</ul>
<h3 id="Table-Editor"><a href="#Table-Editor" class="headerlink" title="Table Editor"></a><a href="https://github.com/vkocubinsky/SublimeTableEditor">Table Editor</a></h3><ul>
<li>键入表格是个体力活，Table Editor 可以帮助我们减轻工作量。</li>
<li>Ctrl + Alt + P调出控制台，Enable to current syntax。</li>
</ul>
<h3 id="SublimeTemp"><a href="#SublimeTemp" class="headerlink" title="SublimeTemp"></a><a href="https://github.com/kairyou/SublimeTmpl">SublimeTemp</a></h3><ul>
<li>设置新建文件的模板。</li>
<li>个人设置Ctrl + Alt + 5创建markdown文件。</li>
</ul>
<h3 id="Sublime-Evernote"><a href="#Sublime-Evernote" class="headerlink" title="Sublime-Evernote"></a><a href="https://github.com/bordaigorl/sublime-evernote">Sublime-Evernote</a></h3><ul>
<li>Evernote插件，用于格式化印象笔记内容。</li>
</ul>
<h3 id="Monokai-Extended"><a href="#Monokai-Extended" class="headerlink" title="Monokai Extended"></a><a href="https://github.com/jonschlinkert/sublime-monokai-extended">Monokai Extended</a></h3><ul>
<li>Markdown 格式在 Sublime 中默认无高亮，很多主题也不支持 Markdown 的高亮（包括 Markdown 代码块内的代码）,Monokai Extended刚好可以解决这个问题。</li>
</ul>
<h3 id="Markdown-Extended"><a href="#Markdown-Extended" class="headerlink" title="Markdown Extended"></a><a href="https://github.com/jonschlinkert/sublime-markdown-extended">Markdown Extended</a></h3><ul>
<li>注意需要将 Markdown 的文件格式与 Markdown Extended 这种语法关联起来，做法是点击 Sublime 右下角文档格式，在列表最上方名为 Open all with current extension as 二级列表中选择 Markdown Extended。一种临时设置方式可以是 Shift + Command + P 调出 Command Palette，输入 ssm，选择 Set Syntax: Markdown Extended。</li>
</ul>
<h3 id="MarkdownEditing"><a href="#MarkdownEditing" class="headerlink" title="MarkdownEditing"></a><a href="https://github.com/SublimeText-Markdown/MarkdownEditing">MarkdownEditing</a></h3><ul>
<li>在 Sublime 中编写 Markdown 进行辅助提示。<blockquote>
<p>Option + Command + K - 插入链接：<br>Option + Command + V - 粘贴为链接格式；<br>Shift + Command + K - 插入图片。</p>
</blockquote>
</li>
</ul>
<h3 id="Markdown-Preview"><a href="#Markdown-Preview" class="headerlink" title="Markdown Preview"></a><a href="https://github.com/revolunet/sublimetext-markdown-preview">Markdown Preview</a></h3><ul>
<li>Markdown 文档渲染成想要的文档格式，进行预览。</li>
<li>推荐配置<pre><code>              &#123;
                    &quot;parser&quot;: &quot;github&quot;,
                    &quot;build_action&quot;: &quot;browser&quot;,
                    &quot;enable_mathjax&quot;: true,
                    &quot;enable_uml&quot;: true,
                    &quot;enable_highlight&quot;: true,
                    &quot;enable_pygments&quot;: true,
                    &quot;enabled_extensions&quot;: &quot;github&quot;,
                    &quot;enabled_parsers&quot;: [&quot;github&quot;],
                    &quot;github_mode&quot;: &quot;markdown&quot;,
                    &quot;github_inject_header_ids&quot;: true,
                    &quot;enable_autoreload&quot;: false
              &#125;
</code></pre>
</li>
</ul>
<h3 id="Theme-Dark-Material"><a href="#Theme-Dark-Material" class="headerlink" title="Theme-Dark Material"></a><a href="https://packagecontrol.io/packages/Theme%20-%20Dark%20Material">Theme-Dark Material</a></h3><ul>
<li>Sublime Text 主题，护眼。</li>
<li>Peferences-Setting User:添加<pre><code>              &#123;
                    &quot;color_scheme&quot;: &quot;Packages/Theme - Dark Material/schemes/Dark-Material.tmTheme&quot;,
                    &quot;theme&quot;: &quot;Dark-Material.sublime-theme&quot;，
                    &quot;font_size&quot;: 12,//额外添加字体大小。
              &#125;
</code></pre>
</li>
</ul>
<h3 id="BracketHighlighter"><a href="#BracketHighlighter" class="headerlink" title="BracketHighlighter"></a><a href="https://packagecontrol.io/packages/BracketHighlighter">BracketHighlighter</a></h3><ul>
<li>匹配括号内文字的高亮</li>
</ul>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>VMOS 简单抓包</title>
    <url>/p/3880c095/</url>
    <content><![CDATA[<h2 id="添加虚拟机，选择安卓-7-1-极客版"><a href="#添加虚拟机，选择安卓-7-1-极客版" class="headerlink" title="添加虚拟机，选择安卓 7.1 极客版"></a>添加虚拟机，选择安卓 7.1 极客版</h2><h2 id="下载证书并移动证书到系统目录下"><a href="#下载证书并移动证书到系统目录下" class="headerlink" title="下载证书并移动证书到系统目录下"></a>下载证书并移动证书到系统目录下</h2><p>HttpCanary</p>
<ol>
<li>从物理机：HttpCanary - 设置 - HttpCanary 根证书 - 导出HttpCanary根证书 - 选择 System Trusted(.0) 结尾的证书，默认放在<code>/sdcard/HttpCanary/certs</code></li>
<li>将证书导入虚拟机中，可以使用虚拟机自带文件管理器导入。</li>
<li>虚拟机中使用 R.E 文件管理器将证书移动到<code>/system/etc/security/cacerts/</code>中，为证书设置权限</li>
<li>重启虚拟机</li>
</ol>
<p>其它.crt证书</p>
<ol>
<li>进入虚拟机安装.crt证书，得到<code>*.0</code>的证书，路径：<code>/data/misc/user/0/cacerts-added/</code></li>
<li>将其移动到系统路径：<code>/system/etc/security/cacerts</code>，并修改权限</li>
<li>重启</li>
</ol>
<p>命令</p>
<pre><code>// 查看证书信息
openssl x509 -subject_hash_old -in *.crt
输出hash，例：8e77c73a.0
// 重命名证书
mv *.crt 8e77c73a.0
// root 权限
adb root
adb remount
adb shell mount -o rw,remount /system
// 将证书push到对应目录
adb push 8e77c73a.0 /system/etc/security/cacerts
</code></pre>
<h2 id="设置wifi代理"><a href="#设置wifi代理" class="headerlink" title="设置wifi代理"></a>设置wifi代理</h2>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>测试一下在线写博客</title>
    <url>/p/eb3d08ec/</url>
    <content><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这是测试的内容</p>
]]></content>
  </entry>
  <entry>
    <title>微信公众号小程序检测之环境搭建</title>
    <url>/p/960ad29a/</url>
    <content><![CDATA[<p>转载自<a href="https://mp.weixin.qq.com/s/1gnY84QtGQHtMgQsFtE4GQ">公众号</a>。</p>
<h2 id="1、微信内置浏览器开启控制台功能"><a href="#1、微信内置浏览器开启控制台功能" class="headerlink" title="1、微信内置浏览器开启控制台功能"></a>1、微信内置浏览器开启控制台功能</h2><p><strong>微信企业号应用，微信默认是没有开启调试模式的，没办法像PC端浏览器一样F12开启调试模式，对于安全测试是很不方便的，下面将介绍如何开启微信PC端的内置浏览器调试功能，具体如下：</strong></p>
<p><strong>1.下载<a href="https://dldir1.qq.com/foxmail/wwopen_docFile/devtools_resources.pak">devtools_resources.pak</a></strong></p>
<p><strong>2.微信开启步骤</strong></p>
<p><strong>第一步：将devtools_resources.pak复制到如下目录</strong></p>
<pre><code class="bash">C:\Users\windows登录用户\AppData\Roaming\Tencent\WeChat\All Users\CefResources\2583
</code></pre>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTdHg21squy284BanlSDHXlOFOZBiczhhJhXCwnDcf7EQkEEedZrPlx2A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>第二步：将devtools_resources.pak复制到微信安装根目录</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTwmthRpu6Giaia2ib009EZpHZXHCmDmGSwib7Sr3CBRcFWQPhbsAH6tzVKg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>第三步：并在微信启动快捷方式后面添加参数-remote-debugging-port=8000</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTzRwN8RSiaCSJdN9S4sNI2k1OsqH4aVQUWsBZRzDYjqTEjMnx7pich5fA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>第四步：关闭微信重启，打开任意一个公众号或者企业号鼠标右键就能开启微信内容浏览器的调试模式了</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTZ0oYXlVt82leGD321UomiatjfzXRybUANwREttDGib6UX89944gqNQXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTzrMF848uwshlL59JzDhibBXia8U9f20e5VDcemsiaYRwoHhTh5qUZxtWg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="2、微信开发者工具"><a href="#2、微信开发者工具" class="headerlink" title="2、微信开发者工具"></a>2、微信开发者工具</h2><p><strong>开发者工具可调试公众号网页、小程序等应用</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTvM9jTbDjoNlqakZmY4ybrtHhFG0hb4b5WgL57cQz1xaW3k5kSYticPA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTVYe1RzuaWbrQCIzvpJbYboDQoHGlRXjKzqh1AyhRT9DWMIXyWUjudA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="3、抓包工具：burpsuit"><a href="#3、抓包工具：burpsuit" class="headerlink" title="3、抓包工具：burpsuit"></a>3、抓包工具：burpsuit</h2><p><strong>burpsuite是用于测试WEB应用程序的集成平台，包含了许多工具。能处理HTTP/S代理、抓包、改包、爆破等功能。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTgeK6q46lWLaUC42MXuLGibYiaKNEKa4nI5FYcBTWxP2yRvXaSvkvtjpQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Proxy代理是拦截HTTP/S的代理服务器，允许拦截，查看，修改数据包。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevT3wWsODWXIgcYLzTFKPX53LAnJyGfNKwJYiaIibicibp526NYs6ldRUJxYg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="4、抓包工具：httpdebugger"><a href="#4、抓包工具：httpdebugger" class="headerlink" title="4、抓包工具：httpdebugger"></a>4、抓包工具：httpdebugger</h2><p><strong>HTTPdebugger是一个无代理的HTTP嗅探器，具有干净的UI和非常易于使用的特性。不会更改代理的浏览器配置。可以显示来自任何浏览器和JAVA、.NET应用程序的HTTP/S通信。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTLzOmk3gmRiaqhLicEf9mG64uotNSvibdYvFQ0txpRBYOTHEPWWWqfu7ZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="5、代理转发：proxifier"><a href="#5、代理转发：proxifier" class="headerlink" title="5、代理转发：proxifier"></a>5、代理转发：proxifier</h2><p><strong>Proxifier是一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevTM9sE3sic5iauVgrHGpePrgibiaL5kVSdyC3BxArCBee1kN8Xsn3YFPa3xw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevT7ZOTRXP8tiaI4Ccib9fvcWdfJhhK1NcFIIUq81ChTNkuDZdeoqibibwUIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="6、编解码：CyerChef"><a href="#6、编解码：CyerChef" class="headerlink" title="6、编解码：CyerChef"></a>6、编解码：CyerChef</h2><p><strong>CyberChef 是一个简单、直观的Web 应用程序，用于在Web 浏览器中执行各种“网络”操作。这些操作包括创建hexdumps、简单编码（如XOR或Base64）、复杂加密（如AES，DES和Blowfish）、数据压缩和解压缩、计算哈希和校验和、IPv6和X.509解析等。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YknTYfPDxUQbkicbSCMticQJz3kTOHxevT3IpC4vNZ4xypjl5ibsY5vdxxmQnleYYAuz8saLR22vibpLvBlnCqaZ2g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="7、常见编解码"><a href="#7、常见编解码" class="headerlink" title="7、常见编解码"></a>7、常见编解码</h2><p><strong>常见编码：urlencode、base64、unicode</strong></p>
<p><strong>常见加密：Hash散列：MD5、SHA1、SM3</strong></p>
<p><strong>对称加密：AES、DES、SM4</strong></p>
<p><strong>非对称加密：RSA、SM2</strong></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>wx-ggbot-tutorial</title>
    <url>/p/e7f72a51/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>wsl2 使用</title>
    <url>/p/b5249cc1/</url>
    <content><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>想要在Windows 10上启用WLS2，需要满足以下条件：</p>
<p>Windows 10 版本 1903 Build 19362，或高于该版本<br>如果是ARM64的系统，则需要版本2004 Build 19041，或高于该版本 
　</p>
<h2 id="为WSL启用Windows服务"><a href="#为WSL启用Windows服务" class="headerlink" title="为WSL启用Windows服务"></a>为WSL启用Windows服务</h2><p>想要在Windows 10上运行WSL，首先需要启用Windows上的一些服务，这些服务默认是关闭的。<br>开始菜单，搜索 PowerShell，右键 PowerShell，选择使用管理员运行。</p>
<p>run-powershell</p>
<h3 id="在打开的-PowerShell-终端，执行如下命令："><a href="#在打开的-PowerShell-终端，执行如下命令：" class="headerlink" title="在打开的 PowerShell 终端，执行如下命令："></a>在打开的 PowerShell 终端，执行如下命令：</h3><pre><code class="bash">PS C:\Windows\system32&gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
</code></pre>
<p>[dism.exe]是Windows的部署映像服务和管理工具，上面的命令开启了WSL的功能。</p>
<p>以上命令执行成功之后，继续执行如下命令来开启Hyper-V的功能</p>
<pre><code class="bash">PS C:\Windows\system32&gt; dism.exe /online /enable-feature /featurename:VirutalMachinePlatform /all /norestart
</code></pre>
<p>完成以上操作之后，需要重启Windows操作系统，重启之后再次登陆系统。<br>接下来需要从微软下载一个最新的Linux内核升级包并安装，下载安装包 wsl_update_x64.msi，下载完成后直接安装。</p>
<p>完成之后，以管理员身份运行 PowerShell，执行如下命令来设置wsl使用的默认版本</p>
<pre><code class="bash">PS C:\Windows\system32&gt; wsl --set-default-version 2
</code></pre>
<p>这里我们将默认设置为 wsl 2 。</p>
<p>上述步骤就完成了WSL2的启用，接下来将使用WSL2安装基于Linux的发行版本（Ubuntu 20.04）。</p>
<h2 id="使用WSL安装Ubuntu-20-04"><a href="#使用WSL安装Ubuntu-20-04" class="headerlink" title="使用WSL安装Ubuntu 20.04"></a>使用WSL安装Ubuntu 20.04</h2><p>在开启WSL功能之后，安装一个Linux的分发版很简单，只需要打开Windows应用商店（Microsoft Store），这里我们将安装Ubuntu 20.04分发版。</p>
<p>microsoft-store</p>
<p>打开应用商店之后，直接在应用商店中搜索 Linux ，将看有很多分发版本的选项，这里选择 Ubuntu 20.04，点击 获取 将应用加入账号，然后在点击 安装 按钮进行安装。</p>
<p>install-ubuntu</p>
<p>安装完成之后，就可以点击 启动 运行Ubuntu子系统，第一次运行需要一些时间来进行初始化配置，然后会提示输入Linux系统的用户名和密码。<br>这里的用户名和密码不需要与Windows系统的用户名和密码一致，但可以通过sudo来获取管理权限。</p>
<p>ubuntu-init</p>
<p>当完成初始化之后，就可以使用该Linux子系统了，当然是以终端的方式。</p>
<h2 id="安装Wdindows终端应用（Windows-Terminal）"><a href="#安装Wdindows终端应用（Windows-Terminal）" class="headerlink" title="安装Wdindows终端应用（Windows Terminal）"></a>安装Wdindows终端应用（Windows Terminal）</h2><p>安装的Ubuntu子系统提供了一个默认的终端，不过微软开源了一个Windows上的终端工具 - Windows Terminal，该工具支持很多自定义配置，同时支持Windows的Powershell，也支持Linux子系统，因此可以安装使用。</p>
<p>直接在应用商店搜索 Terminal ，选择 Windows Terminal 进行安装，安装完成之后可通过开始菜单启动</p>
<p>windows-termial</p>
<p>Windows Terminal默认是打开Powershell的，不过其支持多标签，点击标题栏上 + 服务旁边的下拉按钮，选择Ubuntu-20.04，新标签就会打开Ubuntu的这个子系统终端</p>
<p>termianl-ubuntu</p>
<p>Windows Termial支持很多自定义配置，具体请参考其文档。</p>
<h2 id="可能遇到的错误"><a href="#可能遇到的错误" class="headerlink" title="可能遇到的错误"></a>可能遇到的错误</h2><ul>
<li>WslRegisterDistribution failed with error: 0x800701bc</li>
</ul>
<p>解决方案：造成该问题的原因是WSL版本由原来的WSL1升级到WSL2后，内核没有升级，前往微软WSL官网下载安装适用于 x64 计算机的最新 WSL2 Linux 内核更新包即可。</p>
<p>下载链接：<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p>
<h2 id="忘记账户登陆密码"><a href="#忘记账户登陆密码" class="headerlink" title="忘记账户登陆密码"></a>忘记账户登陆密码</h2><p>管理员打开 powershell</p>
<pre><code>PS C:\Windows\system32&gt; wsl -u root
root@DESKTOP-91MGDB0:/mnt/c/Windows/system32# passwd usernamme
New password:
Retype new password:
passwd: password updated successfully
root@DESKTOP-91MGDB0:/mnt/c/Windows/system32#
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们在Windows 10上安装了一个全功能的Linux环境，可以使用该环境进行一些Linxu的系统实验，以及进行Linxu应用的开发（配合VSCode的wsl插件更加方便）。除了Ubuntu分发版，微软应用商店里还提供了其他支持的分发版本，包括Debian，openSUSE，Kali等，你也可以选择安装多个环境。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000040143442">在Windows 10上安装WSL2</a></li>
<li><a href="https://blog.csdn.net/qq_18625805/article/details/109732122">https://blog.csdn.net/qq_18625805/article/details/109732122</a></li>
</ul>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>wsl2</tag>
      </tags>
  </entry>
  <entry>
    <title>公众号图片批量处理以及一键排版</title>
    <url>/p/8b334f02/</url>
    <content><![CDATA[<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>编写css主题样式，使用 <a href="https://github.com/cglol/markdown-css">markdown-css</a>进行预览</li>
<li>将css主题导入 typora ，在typora中选择主题实时预览，然后直接复制到微信公众号里，实现发布。</li>
</ol>
<p>注：typora 图片上传使用 <a href="https://github.com/Molunerfinn/PicGo">PicGo</a>，使用 <a href="http://www.imagemagick.com.cn/commands.html">imagemagisck</a> 进行图片处理、拼接，再通过 <a href="https://getsharex.com/">sharex</a> 对图片进行简单编辑</p>
<p>微信公众号封面图获取，可以在网上找图片资源（卡通），然后通过 <a href="https://bigjpg.com/zh">bigjpg</a> 将模糊图片转为高清图片。</p>
<h2 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h2><p>Typora 是一款简约派 Markdown 编辑器，支持「所见即所得」的编辑模式.</p>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>这里使用 阿里云 OSS</p>
<p>可以<a href="https://blog.csdn.net/muxuen/article/details/122441469">参考</a></p>
<h2 id="markdown-css"><a href="#markdown-css" class="headerlink" title="markdown-css"></a>markdown-css</h2><p>我这里 windows 使用 pip install markdown-css 之后不能直接使用 markdown-css 命令，所以在 wsl2 中安装了一下</p>
<pre><code class="bash">cd markdown-css
pip install -r requirements.txt
pip install markdown-css
</code></pre>
<p>使用：将 typora 导出的无格式 html 和 css 样式放在一个文件夹中，修改 css 样式，在该文件夹中执行命令，打开public/help.html文件 进行预览</p>
<pre><code class="bash">markdown-css help.html --style=xiaolai.css --out=public 
</code></pre>
<h2 id="导入-typora-主题"><a href="#导入-typora-主题" class="headerlink" title="导入 typora 主题"></a>导入 typora 主题</h2><p>1、将修改后的 css 样式导入到typora主题目录中（可以在文件-偏好设置-外观-打开主题目录）</p>
<p>2、重启typora，然后在主题中选择</p>
<h2 id="imagemagick-简单使用"><a href="#imagemagick-简单使用" class="headerlink" title="imagemagick 简单使用"></a>imagemagick 简单使用</h2><p>图片去色：将small000.png small001.png small002.png small003.png 批量去色，保存为 gray0.png gray1.png gray2.png gray3.png</p>
<pre><code>magick small%03d.png[0-3] -colorspace Gray gray%d.png
</code></pre>
<p>横向拼接多个图片，将gray0.png gray1.png gray2.png gray3.png 横向拼接，保存为share.jpg</p>
<pre><code>magick convert +append gray%d.png[0-3] share.jpg
</code></pre>
<p>图片指定大小：将share.jpg 等比例缩小，宽为1030px，保存为smallshare.jpg</p>
<pre><code>magick &#39;share.jpg&#39; -resize 1030 smallshare.jpg
</code></pre>
<h2 id="sharex"><a href="#sharex" class="headerlink" title="sharex"></a>sharex</h2><p>使用sharex 对上面图片简单进行编辑，保存</p>
<h2 id="bigjpg"><a href="#bigjpg" class="headerlink" title="bigjpg"></a>bigjpg</h2><p>使用技术栈：<strong>waifu2x</strong></p>
<p>类似国外网站有<a href="https://waifu2x.io/">waifu2x</a>，**<a href="https://github.com/lltcggie/waifu2x-caffe"> waifu2x-caffe</a>**（github已不再维护，windows软件）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://hiyongz.github.io/posts/front-end-for-typora-css/">typora主题配置：公众号一键排版</a></p>
</li>
<li><p><a href="http://wecatch.me/markdown-css/">markdown-css</a></p>
</li>
<li><p><a href="https://sspai.com/post/44668">下载的图片太模糊？8 个方法把它变清晰</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>公众号</category>
      </categories>
      <tags>
        <tag>typora</tag>
        <tag>imagemagisk</tag>
      </tags>
  </entry>
</search>
